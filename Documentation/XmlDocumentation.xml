<assembly>
<enum name="BrightWire.ColumnType">
	<summary>
		Data table column type
	</summary>
	<value name="Null" value="0" summary="Nothing" />
	<value name="Boolean" value="1" summary="Boolean values" />
	<value name="Byte" value="2" summary="Byte values" />
	<value name="Int" value="3" summary="Integer values" />
	<value name="Long" value="4" summary="Long values" />
	<value name="Float" value="5" summary="Float values" />
	<value name="Double" value="6" summary="Double values" />
	<value name="String" value="7" summary="String values" />
	<value name="Date" value="8" summary="Date values" />
	<value name="IndexList" value="9" summary="List of indices" />
	<value name="WeightedIndexList" value="10" summary="Weighted list of indices" />
	<value name="Vector" value="11" summary="Vector of floats" />
	<value name="Matrix" value="12" summary="Matrix of floats" />
	<value name="Tensor" value="13" summary="3D tensor of floats" />
</enum>
<enum name="BrightWire.Models.Bayesian.NaiveBayes.ColumnType">
	<summary>
		The type of data within the column
	</summary>
	<value name="ContinuousGaussian" value="0" summary="Continuous values" />
	<value name="Categorical" value="1" summary="Categorical values" />
</enum>
<enum name="BrightWire.DistanceMetric">
	<summary>
		Distance metrics
	</summary>
	<value name="Euclidean" value="0" summary="Euclidean Distance" />
	<value name="Cosine" value="1" summary="Cosine Distance Metric" />
	<value name="Manhattan" value="2" summary="Manhattan Distance" />
	<value name="MeanSquared" value="3" summary="Means Square Error" />
	<value name="SquaredEuclidean" value="4" summary="Square Euclidean" />
</enum>
<enum name="BrightWire.GaussianVarianceCalibration">
	<summary>
		Gaussian weight initialisation type
	</summary>
	<value name="SquareRootN" value="0" summary="Variances are calibrated by dividing by the square root of the connection count" />
	<value name="SquareRoot2N" value="1" summary="Variances are calibrated by multiplying by twice the square root of the connection count" />
</enum>
<enum name="BrightWire.GaussianVarianceCount">
	<summary>
		Gaussian variance count
	</summary>
	<value name="None" value="0" summary="No variance calibration is applied" />
	<value name="FanIn" value="1" summary="The count of incoming connections is used" />
	<value name="FanOut" value="2" summary="The count of outgoing connections is used" />
	<value name="FanInFanOut" value="3" summary="The count incoming and outgoing connections is used" />
</enum>
<enum name="BrightWire.MiniBatchSequenceType">
	<summary>
		Mini batch type
	</summary>
	<value name="Standard" value="0" summary="Standard batch type (non sequential batches have a single standard sequence item)" />
	<value name="SequenceStart" value="1" summary="Start of a sequence" />
	<value name="SequenceEnd" value="2" summary="End of a sequence" />
</enum>
<enum name="BrightWire.NormalisationType">
	<summary>
		Data normalisation options
	</summary>
	<value name="Standard" value="0" summary="Normalises based on standard deviation" />
	<value name="Manhattan" value="1" summary="Normalise from manhattan distance" />
	<value name="Euclidean" value="2" summary="Normalise from eucildean distance" />
	<value name="FeatureScale" value="3" summary="Normalise based on min and max values" />
</enum>
<enum name="BrightWire.TrainingErrorCalculation">
	<summary>
		Describes how to calculate the training error
	</summary>
	<value name="None" value="0" summary="Do not calculate the training error" />
	<value name="Fast" value="1" summary="Compare the output against the target output" />
</enum>

<interface name="BrightWire.I3DTensor" base="System.IDisposable">
	<summary>
		A list of matrices
	</summary>
		<property type="System.Int32" name="RowCount">
		<summary>The number of rows in each matrix</summary>
	</property>
	<property type="System.Int32" name="ColumnCount">
		<summary>The number of columns in each matrix</summary>
	</property>
	<property type="System.Int32" name="Depth">
		<summary>The number of matrices</summary>
	</property>
	<property type="BrightWire.Models.FloatTensor" name="Data">
		<summary>Converts the current tensor to protobuf format</summary>
	</property>
	<method type="BrightWire.IMatrix" name="GetMatrixAt">
		<summary>Returns a matrix at the specified depth</summary>
				<param type="System.Int32" name="depth" summary="The depth to query" />
			</method>
	<method type="BrightWire.IIndexable3DTensor" name="AsIndexable">
		<summary>Returns an indexable 3D tensor</summary>
			</method>
	<method type="BrightWire.I3DTensor" name="AddPadding">
		<summary>Adds padding to each matrix</summary>
				<param type="System.Int32" name="padding" summary="The padding (both vertical and horizontal)" />
			</method>
	<method type="BrightWire.I3DTensor" name="RemovePadding">
		<summary>Removes padding from each matrix</summary>
				<param type="System.Int32" name="padding" summary="The padding to remove" />
			</method>
	<method type="BrightWire.IMatrix" name="Im2Col">
		<summary>Performs a convolution on each source matrix</summary>
				<param type="System.Int32" name="filterWidth" summary="The filter width" />
				<param type="System.Int32" name="filterHeight" summary="The filter height" />
				<param type="System.Int32" name="stride" summary="The convolution stride" />
			</method>
	<method type="BrightWire.IVector" name="ConvertToVector">
		<summary>Converts the tensor to a vector (each sub matrix is concatenated into a single vector)</summary>
			</method>
	<method type="BrightWire.IMatrix" name="ConvertToMatrix">
		<summary>Converts the tensor to a matrix (each sub matrix becomes a column in the new matrix)</summary>
			</method>
	<method type="BrightWire.I4DTensor" name="ConvertTo4DTensor">
		<summary>Converts the tensor to a 4D tensor (each sub matrix becomes a 3D tensor with the specified rows and columns and depth given by the sub matrix column count)</summary>
				<param type="System.Int32" name="rows" summary="Row count of each 3D tensor" />
				<param type="System.Int32" name="columns" summary="Column count of each 3D tensor" />
			</method>
	<method type="(BrightWire.I3DTensor Result, System.Collections.Generic.IReadOnlyList&lt;(System.Object X, System.Object Y)&gt; Index)" name="MaxPool">
		<summary>Performs a max pooling operation on the tensor</summary>
				<param type="System.Int32" name="filterWidth" summary="The pooling filter width" />
				<param type="System.Int32" name="filterHeight" summary="The pooling filter height" />
				<param type="System.Int32" name="stride" summary="The pooling stride" />
				<param type="System.Boolean" name="calculateIndex" summary="True to calculate the index of each max item" />
			</method>
	<method type="BrightWire.I3DTensor" name="ReverseMaxPool">
		<summary>Reverses a max pooling operation</summary>
				<param type="System.Int32" name="rows" summary="Input rows" />
				<param type="System.Int32" name="columns" summary="Input columns" />
				<param type="System.Collections.Generic.IReadOnlyList&lt;(System.Object X, System.Object Y)&gt;" name="indexList" summary="The indices of the maximum values" />
			</method>
	<method type="BrightWire.IMatrix" name="ReverseIm2Col">
		<summary>Reverses a im2col operation</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;System.Collections.Generic.IReadOnlyList&lt;BrightWire.IVector&gt;&gt;" name="filter" summary="The rotated filters" />
				<param type="System.Int32" name="inputHeight" summary="Height of the input tensor" />
				<param type="System.Int32" name="inputWidth" summary="Width of the input tensor" />
				<param type="System.Int32" name="inputDepth" summary="Depth of the input tensor" />
				<param type="System.Int32" name="padding" summary="Input padding" />
				<param type="System.Int32" name="filterHeight" summary="Height of each filter" />
				<param type="System.Int32" name="filterWidth" summary="Width of each filter" />
				<param type="System.Int32" name="stride" summary="Filter stride" />
			</method>
	<method type="BrightWire.IMatrix" name="CombineDepthSlices">
		<summary>Adds each depth slice into a single matrix</summary>
			</method>
	<method type="System.Void" name="AddInPlace">
		<summary>Adds the other tensor to the current tensor</summary>
				<param type="BrightWire.I3DTensor" name="tensor" summary="Tensor to add" />
			</method>
	<method type="BrightWire.I3DTensor" name="Multiply">
		<summary>Multiplies the tensor with the other matrix</summary>
				<param type="BrightWire.IMatrix" name="matrix" summary="Matrix to multiply with" />
			</method>
	<method type="System.Void" name="AddToEachRow">
		<summary>Adds the vector to each row of the tensor</summary>
				<param type="BrightWire.IVector" name="vector" summary="Vector to add to each row" />
			</method>
	<method type="BrightWire.I3DTensor" name="TransposeThisAndMultiply">
		<summary>Transpose each sub matrix in the current tensor before multiplying it with each each sub tensor (converted to a matrix)</summary>
				<param type="BrightWire.I4DTensor" name="tensor" summary="Tensor to multiply with" />
			</method>
</interface>
<interface name="BrightWire.I4DTensor" base="System.IDisposable">
	<summary>
		A list of 3D tensors
	</summary>
		<property type="System.Int32" name="RowCount">
		<summary>The number of rows in each 3D tensor</summary>
	</property>
	<property type="System.Int32" name="ColumnCount">
		<summary>The number of columns in each 3D tensor</summary>
	</property>
	<property type="System.Int32" name="Depth">
		<summary>The depth of each 3D tensor</summary>
	</property>
	<property type="System.Int32" name="Count">
		<summary>The count of 3D tensors</summary>
	</property>
	<method type="BrightWire.I3DTensor" name="GetTensorAt">
		<summary>Returns the tensor at the specified index</summary>
				<param type="System.Int32" name="index" summary="The index to query" />
			</method>
	<method type="System.Collections.Generic.IReadOnlyList&lt;BrightWire.IIndexable3DTensor&gt;" name="AsIndexable">
		<summary>Returns an indexable list of 3D tensors</summary>
			</method>
	<method type="BrightWire.I4DTensor" name="AddPadding">
		<summary>Adds padding to the 4D tensor</summary>
				<param type="System.Int32" name="padding" summary="Padding to add to the left, top, right and bottom edges of the tensor" />
			</method>
	<method type="BrightWire.I4DTensor" name="RemovePadding">
		<summary>Removes padding from the 4D tensor</summary>
				<param type="System.Int32" name="padding" summary="Padding to remove from the left, top, right and bottom edges of the tensor" />
			</method>
	<method type="(BrightWire.I4DTensor Result, System.Collections.Generic.IReadOnlyList&lt;System.Collections.Generic.IReadOnlyList&lt;(System.Object X, System.Object Y)&gt;&gt; Index)" name="MaxPool">
		<summary>Applies a max pooling operation to the current tensor</summary>
				<param type="System.Int32" name="filterWidth" summary="Max pool filter width" />
				<param type="System.Int32" name="filterHeight" summary="Max pool filter height" />
				<param type="System.Int32" name="stride" summary="Filter stride" />
				<param type="System.Boolean" name="calculateIndex" summary="True to remember the indices of each max value for later backpropagation" />
			</method>
	<method type="BrightWire.I4DTensor" name="ReverseMaxPool">
		<summary>Reverses a max pool operation</summary>
				<param type="System.Int32" name="rows" summary="Input tensor rows" />
				<param type="System.Int32" name="columns" summary="Input tensor columns" />
				<param type="System.Collections.Generic.IReadOnlyList&lt;System.Collections.Generic.IReadOnlyList&lt;(System.Object X, System.Object Y)&gt;&gt;" name="indexList" summary="Saved list of indexes from MaxPool operation" />
			</method>
	<method type="BrightWire.I3DTensor" name="Im2Col">
		<summary>Applies the convolutional filter to each 3D tensor, producing a 3D tensor which can be multipled by the filter matrix</summary>
				<param type="System.Int32" name="filterWidth" summary="Filter width" />
				<param type="System.Int32" name="filterHeight" summary="Filter height" />
				<param type="System.Int32" name="stride" summary="Filter stride" />
			</method>
	<method type="BrightWire.I3DTensor" name="ReverseIm2Col">
		<summary>Reverse a previously applied im2Col</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;System.Collections.Generic.IReadOnlyList&lt;BrightWire.IVector&gt;&gt;" name="filter" summary="List of filters that have been rotated 180 degrees" />
				<param type="System.Int32" name="inputHeight" summary="Height of the input 4D tensor" />
				<param type="System.Int32" name="inputWidth" summary="Width of the input 4D tensor" />
				<param type="System.Int32" name="inputDepth" summary="Depth of the input 4D tensor" />
				<param type="System.Int32" name="padding" summary="Amount of padding that was applied to the input 4D tensor before im2col" />
				<param type="System.Int32" name="filterWidth" summary="Filter width" />
				<param type="System.Int32" name="filterHeight" summary="Filter height" />
				<param type="System.Int32" name="stride" summary="Filter stride" />
			</method>
	<method type="BrightWire.IMatrix" name="ConvertToMatrix">
		<summary>Converts the 4D tensor to a matrix in which each column is a 3D tensor in vector form</summary>
			</method>
	<method type="BrightWire.IVector" name="ColumnSums">
		<summary>Sums the columns of each sub-tensor's sub matrix</summary>
			</method>
</interface>
<interface name="BrightWire.IAction" base="">
	<summary>
		An action to perform when a signal reaches a node
	</summary>
		<method type="BrightWire.IGraphData" name="Execute">
		<summary>Executes the action</summary>
				<param type="BrightWire.IGraphData" name="input" summary="Current graph signal" />
				<param type="BrightWire.IContext" name="context" summary="Graph context" />
			</method>
	<method type="System.String" name="Serialise">
		<summary>Serialises the action to a string</summary>
			</method>
	<method type="System.Void" name="Initialise">
		<summary>Initialises the action</summary>
				<param type="System.String" name="data" summary="Previously serialised data" />
			</method>
</interface>
<interface name="BrightWire.IAdaptiveDataSource" base="">
	<summary>
		Adaptive data sources apply the output from a preliminary graph
	</summary>
		<property type="BrightWire.INode" name="AdaptiveInput">
		<summary>The input node of the preliminary graph</summary>
	</property>
	<method type="BrightWire.Models.DataSourceModel" name="GetModel">
		<summary>Gets the serialised preliminary graph</summary>
				<param type="System.String" name="name" summary="Optional name to give the data source" />
			</method>
</interface>
<interface name="BrightWire.IBackpropagation" base="System.IDisposable">
	<summary>
		Backpropagation handler
	</summary>
		<method type="System.Void" name="Backward">
		<summary>Backpropagate</summary>
				<param type="BrightWire.INode" name="fromNode" summary="Node that sent the signal" />
				<param type="BrightWire.IGraphData" name="errorSignal" summary="Error signal" />
				<param type="BrightWire.IContext" name="context" summary="Graph context" />
				<param type="System.Collections.Generic.IReadOnlyList&lt;BrightWire.INode&gt;" name="parents" summary="The current node's parents" />
			</method>
</interface>
<interface name="BrightWire.ICanInitialiseNode" base="">
	<summary>
		Interface that allows the node to be initialised
	</summary>
		<method type="System.Void" name="Initialise">
		<summary>Initialise the node</summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="factory" summary="Graph factory" />
				<param type="System.String" name="id" summary="Node unique id" />
				<param type="System.String" name="name" summary="Friendly name" />
				<param type="System.String" name="description" summary="Node description" />
				<param type="System.Byte[]" name="data" summary="Serialisation data" />
			</method>
</interface>
<interface name="BrightWire.ICanSerialise" base="">
	<summary>
		Serialisation interface for graph components
	</summary>
		<method type="System.Void" name="WriteTo">
		<summary>Writes the node state to the binary writer</summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="ReadFrom">
		<summary>Reads the node state</summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="factory" summary="Graph factory" />
				<param type="System.IO.BinaryReader" name="reader" summary="Binary reader that holds the node's state" />
			</method>
</interface>
<interface name="BrightWire.ICanSerialiseToStream" base="">
	<summary>
		Standard serialisation interface
	</summary>
		<method type="System.Void" name="SerialiseTo">
		<summary>Writes the current object state to the stream</summary>
				<param type="System.IO.Stream" name="stream" summary="Stream to write to" />
			</method>
	<method type="System.Void" name="DeserialiseFrom">
		<summary>Reads the current object state from the stream</summary>
				<param type="System.IO.Stream" name="stream" summary="Stream to read from" />
				<param type="System.Boolean" name="clear" summary="True to clear the existing state" />
			</method>
</interface>
<interface name="BrightWire.IColumn" base="">
	<summary>
		A column within a data table
	</summary>
		<property type="System.String" name="Name">
		<summary>The name of the column</summary>
	</property>
	<property type="BrightWire.ColumnType" name="Type">
		<summary>The data type</summary>
	</property>
	<property type="System.Int32" name="NumDistinct">
		<summary>The number of distinct values</summary>
	</property>
	<property type="System.Boolean" name="IsContinuous">
		<summary>True if the value is continuous (not categorical)</summary>
	</property>
	<property type="System.Boolean" name="IsTarget">
		<summary>True if the column is a classification target (or label)</summary>
	</property>
</interface>
<interface name="BrightWire.Models.Bayesian.NaiveBayes.IColumn" base="">
	<summary>
		A column of the data table
	</summary>
		<property type="BrightWire.Models.Bayesian.NaiveBayes.ColumnType" name="Type">
		<summary>The type of the column</summary>
	</property>
	<property type="System.Int32" name="ColumnIndex">
		<summary>The column index</summary>
	</property>
</interface>
<interface name="BrightWire.IColumnInfo" base="">
	<summary>
		Column statistics within a data table
	</summary>
		<property type="System.Int32" name="ColumnIndex">
		<summary>The index of the column in the data table</summary>
	</property>
	<property type="System.Collections.Generic.IEnumerable&lt;System.Object&gt;" name="DistinctValues">
		<summary>The distinct values within the column</summary>
	</property>
	<property type="System.Nullable&lt;System.Int32&gt;" name="NumDistinct">
		<summary>The number of distinct values (or null if there are too many)</summary>
	</property>
</interface>
<interface name="BrightWire.IContext" base="System.IDisposable">
	<summary>
		Graph context
	</summary>
		<property type="System.Boolean" name="IsTraining">
		<summary>True if the graph is currently training</summary>
	</property>
	<property type="BrightWire.INode" name="Source">
		<summary>Node that sent the current signal</summary>
	</property>
	<property type="BrightWire.IGraphData" name="Data">
		<summary>Current signal</summary>
	</property>
	<property type="BrightWire.IExecutionContext" name="ExecutionContext">
		<summary>Current execution context</summary>
	</property>
	<property type="BrightWire.ILearningContext" name="LearningContext">
		<summary>Current learning context (optional)</summary>
	</property>
	<property type="BrightWire.ILinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary>Linear algebra provider</summary>
	</property>
	<property type="BrightWire.IMiniBatchSequence" name="BatchSequence">
		<summary>Current mini batch sequence</summary>
	</property>
	<method type="System.Void" name="AddForward">
		<summary>Records node execution</summary>
				<param type="BrightWire.IExecutionHistory" name="action" summary="Record of node execution" />
				<param type="System.Func&lt;BrightWire.IBackpropagation&gt;" name="callback" summary="Optional callback to add backpropagation" />
			</method>
	<method type="System.Void" name="AddBackward">
		<summary>Sends a backward error signal</summary>
				<param type="BrightWire.IGraphData" name="errorSignal" summary="Error signal" />
				<param type="BrightWire.INode" name="target" summary="Node to send to" />
				<param type="BrightWire.INode" name="source" summary="Node that sent the error" />
			</method>
	<method type="System.Void" name="AppendErrorSignal">
		<summary>Records an error signal against a node</summary>
				<param type="BrightWire.IGraphData" name="errorSignal" summary="Error signal" />
				<param type="BrightWire.INode" name="forNode" summary="Node to record against" />
			</method>
	<method type="System.Void" name="Backpropagate">
		<summary>Backpropagates the signal</summary>
				<param type="BrightWire.IGraphData" name="delta" summary="Error signal" />
			</method>
	<property type="BrightWire.IGraphData" name="ErrorSignal">
		<summary>Current error signal</summary>
	</property>
	<property type="System.Boolean" name="HasNext">
		<summary>Checks if there is a pending forward graph operation</summary>
	</property>
	<method type="System.Boolean" name="ExecuteNext">
		<summary>Executes the next pending forward graph operation</summary>
			</method>
</interface>
<interface name="BrightWire.ICreateGradientDescent" base="">
	<summary>
		Creates a gradient descent optimisation
	</summary>
		<method type="BrightWire.IGradientDescentOptimisation" name="Create">
		<summary>Creates the gradient descent optimisation</summary>
				<param type="BrightWire.IPropertySet" name="propertySet" summary="The property set that contains initialisation parameters" />
			</method>
</interface>
<interface name="BrightWire.ICreateTemplateBasedGradientDescent" base="">
	<summary>
		Creates gradient descent optimisations based on a matrix
	</summary>
		<method type="BrightWire.IGradientDescentOptimisation" name="Create">
		<summary>Creates the gradient descent optimisation for a particular target matrix</summary>
				<param type="BrightWire.IGradientDescentOptimisation" name="prev" summary="Any other previously created gradient descent optimisation in this context" />
				<param type="BrightWire.IMatrix" name="template" summary="The instance of the matrix that will be updated" />
				<param type="BrightWire.IPropertySet" name="propertySet" summary="The property set that contains initialisation parameters" />
			</method>
</interface>
<interface name="BrightWire.IDataSource" base="">
	<summary>
		Data sources feed data into a graph
	</summary>
		<property type="System.Boolean" name="IsSequential">
		<summary>True if the data is sequential</summary>
	</property>
	<property type="System.Int32" name="InputSize">
		<summary>The size of the input data</summary>
	</property>
	<property type="System.Int32" name="OutputSize">
		<summary>The size of the output data</summary>
	</property>
	<property type="System.Int32" name="InputCount">
		<summary>The number of inputs that can feed into the graph</summary>
	</property>
	<property type="System.Int32" name="RowCount">
		<summary>Number of rows</summary>
	</property>
	<method type="BrightWire.IMiniBatch" name="Get">
		<summary>Gets a mini batch with the specified rows</summary>
				<param type="BrightWire.IExecutionContext" name="executionContext" summary="Graph execution context" />
				<param type="System.Collections.Generic.IReadOnlyList&lt;System.Int32&gt;" name="rows" summary="List of rows" />
			</method>
	<method type="System.Collections.Generic.IReadOnlyList&lt;System.Collections.Generic.IReadOnlyList&lt;System.Int32&gt;&gt;" name="GetBuckets">
		<summary>For sequential data, returns the row indexes grouped by sequence length</summary>
			</method>
	<method type="System.Void" name="OnBatchProcessed">
		<summary>Called when the current batch has completed</summary>
				<param type="BrightWire.IContext" name="context" summary="" />
			</method>
	<method type="BrightWire.IDataSource" name="CloneWith">
		<summary>Creates a new data source, using the current as a template but replacing the data table</summary>
				<param type="BrightWire.IDataTable" name="dataTable" summary="The new data table" />
			</method>
</interface>
<interface name="BrightWire.IDataTable" base="BrightWire.IHaveColumns">
	<summary>
		Tabular data table
	</summary>
		<property type="System.Int32" name="RowCount">
		<summary>The number of rows</summary>
	</property>
	<property type="System.Int32" name="TargetColumnIndex">
		<summary>The column of the classification target (defaults to the last column if none set)</summary>
	</property>
	<method type="System.Void" name="Process">
		<summary>Applies each row of the table to the specified processor</summary>
				<param type="BrightWire.IRowProcessor" name="rowProcessor" summary="Will be called with each row" />
			</method>
	<method type="BrightWire.IDataTableAnalysis" name="GetAnalysis">
		<summary>Data table statistics</summary>
			</method>
	<method type="System.Void" name="ForEach">
		<summary>Invokes the callback on each row in the table</summary>
				<param type="System.Action&lt;BrightWire.IRow&gt;" name="callback" summary="Callback that is invoked for each row" />
			</method>
	<method type="System.Void" name="ForEach">
		<summary>Invokes the callback on each row in the table</summary>
				<param type="System.Action&lt;BrightWire.IRow, System.Int32&gt;" name="callback" summary="Callback that is invoked for each row" />
			</method>
	<method type="System.Void" name="ForEach">
		<summary>Invokes the callback on each row in the table</summary>
				<param type="System.Func&lt;BrightWire.IRow, System.Boolean&gt;" name="callback" summary="Callback that is invoked for each row and returns true to continue processing" />
			</method>
	<method type="System.Collections.Generic.IReadOnlyList&lt;BrightWire.IRow&gt;" name="GetSlice">
		<summary>Gets a list of rows</summary>
				<param type="System.Int32" name="offset" summary="The first row index" />
				<param type="System.Int32" name="count" summary="The number of rows to query" />
			</method>
	<method type="System.Collections.Generic.IReadOnlyList&lt;BrightWire.IRow&gt;" name="GetRows">
		<summary>Gets a list of rows</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" name="rowIndex" summary="A sequence of row indices" />
			</method>
	<method type="BrightWire.IRow" name="GetRow">
		<summary>Returns the row at the specified index</summary>
				<param type="System.Int32" name="rowIndex" summary="The row index to retrieve" />
			</method>
	<method type="(BrightWire.IDataTable Training, BrightWire.IDataTable Test)" name="Split">
		<summary>Splits the table into two random tables</summary>
				<param type="System.Nullable&lt;System.Int32&gt;" name="randomSeed" summary="Optional random seed" />
				<param type="System.Double" name="trainingPercentage" summary="The size of the training table (expressed as a value between 0 and 1)" />
				<param type="System.Boolean" name="shuffle" summary="True to shuffle the table before splitting" />
				<param type="System.IO.Stream" name="output1" summary="Optional stream to write the first output table to" />
				<param type="System.IO.Stream" name="output2" summary="Optional stream to write the second output table to" />
			</method>
	<method type="BrightWire.IDataTable" name="Normalise">
		<summary>Creates a normalised version of the current table</summary>
				<param type="BrightWire.NormalisationType" name="normalisationType" summary="The type of normalisation to apply" />
				<param type="System.IO.Stream" name="output" summary="Optional stream to write the normalised table to" />
			</method>
	<method type="BrightWire.IDataTable" name="Normalise">
		<summary>Creates a normalised version of the current table</summary>
				<param type="BrightWire.Models.DataTable.DataTableNormalisation" name="normalisationModel" summary="The normalisation model to apply" />
				<param type="System.IO.Stream" name="output" summary="Optional stream to write the normalised table to" />
			</method>
	<method type="BrightWire.Models.DataTable.DataTableNormalisation" name="GetNormalisationModel">
		<summary>Builds a normalisation model from the table that can be used to normalise data to the same scale</summary>
				<param type="BrightWire.NormalisationType" name="normalisationType" summary="The type of normalisation" />
			</method>
	<method type="System.Collections.Generic.IReadOnlyList&lt;T&gt;" name="GetColumn">
		<summary>Gets a column from the table</summary>
				<param type="System.Int32" name="columnIndex" summary="The column to retrieve" />
			</method>
	<method type="BrightWire.IDataTable" name="Bag">
		<summary>Creates a new data table with bagged rows from the current table</summary>
				<param type="System.Nullable&lt;System.Int32&gt;" name="count" summary="The count of rows to bag" />
				<param type="System.IO.Stream" name="output" summary="Optional stream to write the new table to" />
				<param type="System.Nullable&lt;System.Int32&gt;" name="randomSeed" summary="Optional random seed" />
			</method>
	<method type="System.Collections.Generic.IReadOnlyList&lt;System.Single[]&gt;" name="GetNumericRows">
		<summary>Converts rows to lists of floats</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" name="columns" summary="Optional list of columns to convert (or null for all columns)" />
			</method>
	<method type="System.Collections.Generic.IReadOnlyList&lt;System.Single[]&gt;" name="GetNumericColumns">
		<summary>Gets each specified column (or all columns) as an array of floats</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" name="columns" summary="The columns to return (or null for all)" />
			</method>
	<method type="System.Collections.Generic.IReadOnlyList&lt;(BrightWire.IRow Row, System.String Classification)&gt;" name="Classify">
		<summary>Classifies each row</summary>
				<param type="BrightWire.IRowClassifier" name="classifier" summary="The classifier to use" />
				<param type="System.Action&lt;System.Single&gt;" name="progress" summary="Optional callback that is notified about classification progress" />
			</method>
	<method type="BrightWire.IDataTable" name="SelectColumns">
		<summary>Creates a new data table with the specified columns</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" name="columns" summary="The columns to include in the new table" />
				<param type="System.IO.Stream" name="output" summary="Optional stream to write the new table to" />
			</method>
	<method type="BrightWire.IDataTable" name="Project">
		<summary></summary>
				<param type="System.Func&lt;BrightWire.IRow, System.Collections.Generic.IReadOnlyList&lt;System.Object&gt;&gt;" name="mutator" summary="" />
				<param type="System.IO.Stream" name="output" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;(BrightWire.IDataTable Training, BrightWire.IDataTable Validation)&gt;" name="Fold">
		<summary></summary>
				<param type="System.Int32" name="k" summary="" />
				<param type="System.Nullable&lt;System.Int32&gt;" name="randomSeed" summary="" />
				<param type="System.Boolean" name="shuffle" summary="" />
			</method>
	<method type="System.Collections.Generic.IReadOnlyList&lt;(BrightWire.IDataTable Table, System.String Classification)&gt;" name="ConvertToBinaryClassification">
		<summary>For each classification label - duplicate each data table except for the classification column which is converted to a boolean (true for each matching example)</summary>
			</method>
	<method type="System.Collections.Generic.IReadOnlyList&lt;T&gt;" name="Map">
		<summary>Mutates each row of the table</summary>
				<param type="System.Func&lt;BrightWire.IRow, T&gt;" name="mutator" summary="The function called for each row in the table" />
			</method>
	<method type="BrightWire.IDataTableVectoriser" name="GetVectoriser">
		<summary>Returns an interface that can convert rows in the current table to vectors</summary>
				<param type="System.Boolean" name="useTargetColumnIndex" summary="True to separate the target column index into a separate output vector" />
			</method>
	<method type="BrightWire.IDataTableVectoriser" name="GetVectoriser">
		<summary>Returns an interface that can convert rows in the current table to vectors</summary>
				<param type="BrightWire.Source.Models.DataTable.DataTableVectorisation" name="model" summary="A serialised model to recreate a previous vectorisation" />
			</method>
	<method type="BrightWire.IDataTable" name="CopyWithRows">
		<summary>Returns a copy of the current table</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" name="rowIndex" summary="The list of rows to copy" />
				<param type="System.IO.Stream" name="output" summary="Optional stream to write the new table to" />
			</method>
	<property type="System.String" name="XmlPreview">
		<summary>Returns table meta-data and the top 20 rows of the table as XML</summary>
	</property>
	<property type="System.Boolean" name="HasCategoricalData">
		<summary>Returns true if the data table contains any non-numeric columns</summary>
	</property>
</interface>
<interface name="BrightWire.IDataTableAnalysis" base="">
	<summary>
		Data table statistics
	</summary>
		<property type="System.Collections.Generic.IEnumerable&lt;BrightWire.IColumnInfo&gt;" name="ColumnInfo">
		<summary>List of column statistics</summary>
	</property>
	<property type="BrightWire.IColumnInfo" name="this">
		<summary>Gets the statistics for a particular column</summary>
	</property>
	<property type="System.String" name="AsXml">
		<summary>Returns a summary of the table analysis</summary>
	</property>
</interface>
<interface name="BrightWire.IDataTableBuilder" base="System.IDisposable">
	<summary>
		Used to programatically construct data tables
	</summary>
		<property type="System.Collections.Generic.IReadOnlyList&lt;BrightWire.IColumn&gt;" name="Columns">
		<summary>The list of columns</summary>
	</property>
	<property type="System.Int32" name="RowCount">
		<summary>The number of rows</summary>
	</property>
	<property type="System.Int32" name="ColumnCount">
		<summary>The number of columns</summary>
	</property>
	<method type="BrightWire.IColumn" name="AddColumn">
		<summary>Adds a new column to the data table</summary>
				<param type="BrightWire.ColumnType" name="column" summary="The data type of the new column" />
				<param type="System.String" name="name" summary="The name of the new column" />
				<param type="System.Boolean" name="isTarget" summary="True if the column is a classification target" />
			</method>
	<method type="BrightWire.IRow" name="Add">
		<summary>Adds a new row to the table</summary>
				<param type="System.Object[]" name="data" summary="The data in the new row" />
			</method>
	<method type="BrightWire.IRow" name="Add">
		<summary>Adds a new row to the table</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;System.Object&gt;" name="data" summary="The data in the new row" />
			</method>
	<method type="BrightWire.IDataTable" name="Build">
		<summary>Creates the new data table</summary>
			</method>
	<method type="System.Void" name="Flush">
		<summary>Ensures all data has been written</summary>
			</method>
	<method type="System.Void" name="WriteIndexTo">
		<summary>Writes the index data to the specified stream</summary>
				<param type="System.IO.Stream" name="stream" summary="The stream to hold the index data" />
			</method>
</interface>
<interface name="BrightWire.IDataTableVectoriser" base="">
	<summary>
		Converts data table rows to vectors
	</summary>
		<method type="BrightWire.Models.FloatVector" name="GetInput">
		<summary>Vectorises the input columns of the specified row</summary>
				<param type="BrightWire.IRow" name="row" summary="The row to vectorise" />
			</method>
	<method type="BrightWire.Models.FloatVector" name="GetOutput">
		<summary>Vectorises the output column of the specified row</summary>
				<param type="BrightWire.IRow" name="row" summary="The row to vectorise" />
			</method>
	<property type="System.Int32" name="InputSize">
		<summary>The size of the input vector</summary>
	</property>
	<property type="System.Int32" name="OutputSize">
		<summary>The size of the output vector</summary>
	</property>
	<method type="System.String" name="GetOutputLabel">
		<summary>Returns the classification label</summary>
				<param type="System.Int32" name="columnIndex" summary="The data table column index" />
				<param type="System.Int32" name="vectorIndex" summary="The one hot vector index" />
			</method>
	<method type="BrightWire.Source.Models.DataTable.DataTableVectorisation" name="GetVectorisationModel">
		<summary>Gets the serialisable model to recreate this vectorisation</summary>
			</method>
</interface>
<interface name="BrightWire.IErrorMetric" base="">
	<summary>
		Error metrics used to quantify machine learning
	</summary>
		<property type="System.Boolean" name="DisplayAsPercentage">
		<summary>True if the result should be formatted as a percentage</summary>
	</property>
	<method type="System.Single" name="Compute">
		<summary>Computes the error between the output vector and target vector</summary>
				<param type="BrightWire.Models.FloatVector" name="output" summary="The vector that was the output of the model" />
				<param type="BrightWire.Models.FloatVector" name="targetOutput" summary="The vector that the model was expected to output" />
			</method>
	<method type="BrightWire.IMatrix" name="CalculateGradient">
		<summary>Calculates the gradient of the error function</summary>
				<param type="BrightWire.IContext" name="context" summary="The graph context" />
				<param type="BrightWire.IMatrix" name="output" summary="The mini batch of output vectors" />
				<param type="BrightWire.IMatrix" name="targetOutput" summary="The mini batch of expected target vectors" />
			</method>
</interface>
<interface name="BrightWire.IExecutionContext" base="System.IDisposable">
	<summary>
		Graph execution context
	</summary>
		<method type="System.Void" name="SetMemory">
		<summary>Writes to a named memory slot</summary>
				<param type="System.String" name="slotName" summary="Slot name" />
				<param type="BrightWire.IMatrix" name="memory" summary="Data" />
			</method>
	<method type="BrightWire.IMatrix" name="GetMemory">
		<summary>Reads from a named memory slot</summary>
				<param type="System.String" name="slotName" summary="Slot name" />
			</method>
	<method type="BrightWire.IGraphOperation" name="GetNextOperation">
		<summary>Gets the next queued graph operation (if any)</summary>
			</method>
	<method type="System.Void" name="Add">
		<summary>Adds a list of graph operations to the queue</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;BrightWire.IGraphOperation&gt;" name="operationList" summary="List of operations" />
			</method>
	<property type="BrightWire.ILinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary>Linear algebra provider</summary>
	</property>
	<property type="System.Int32" name="RemainingOperationCount">
		<summary>How many operations remain queued</summary>
	</property>
	<method type="System.Void" name="RegisterContinuation">
		<summary>Registers a continuation that will be executed after the current sequence has been processed in full</summary>
				<param type="BrightWire.IMiniBatchSequence" name="sequence" summary="Sequence index" />
				<param type="System.Action&lt;BrightWire.IContext&gt;" name="callback" summary="Continuation" />
			</method>
	<property type="System.Boolean" name="HasContinuations">
		<summary>True if there are registered continuations</summary>
	</property>
	<method type="System.Void" name="Continue">
		<summary>Execute any registered continuation for this context</summary>
				<param type="BrightWire.IContext" name="context" summary="Context with an associated IMiniBatchSequence" />
			</method>
</interface>
<interface name="BrightWire.IExecutionHistory" base="">
	<summary>
		Record of node execution
	</summary>
		<property type="BrightWire.INode" name="Source">
		<summary>Node that was executed</summary>
	</property>
	<property type="System.Collections.Generic.IReadOnlyList&lt;BrightWire.INode&gt;" name="Parents">
		<summary>The node's parents</summary>
	</property>
	<property type="BrightWire.IGraphData" name="Data">
		<summary>Node output signal</summary>
	</property>
	<property type="BrightWire.IBackpropagation" name="Backpropagation">
		<summary>Optional backpropagation</summary>
	</property>
</interface>
<interface name="BrightWire.IFeedForward" base="BrightWire.INode">
	<summary>
		Feed forward layer
	</summary>
		<property type="System.Int32" name="InputSize">
		<summary>Size of incoming connections</summary>
	</property>
	<property type="System.Int32" name="OutputSize">
		<summary>Size of outgoing connections</summary>
	</property>
	<property type="BrightWire.IVector" name="Bias">
		<summary>Bias vector</summary>
	</property>
	<property type="BrightWire.IMatrix" name="Weight">
		<summary>Weight matrix</summary>
	</property>
	<method type="System.Void" name="UpdateWeights">
		<summary>Updates the weights</summary>
				<param type="BrightWire.IMatrix" name="delta" summary="Weight delta matrix" />
				<param type="BrightWire.ILearningContext" name="context" summary="Graph learning context" />
			</method>
</interface>
<interface name="BrightWire.IGpuLinearAlgebraProvider" base="">
	<summary>
		Helper methods when using the GPU linear algebra provider
	</summary>
		<method type="System.Void" name="BindThread">
		<summary>Binds the current thread to the cuda context (used when using the same cuda provider from multiple threads)</summary>
			</method>
</interface>
<interface name="BrightWire.IGradientDescentOptimisation" base="System.IDisposable">
	<summary>
		Gradient descent optimisation
	</summary>
		<method type="System.Void" name="Update">
		<summary>Updates the matrix with the delta</summary>
				<param type="BrightWire.IMatrix" name="source" summary="The matrix to update" />
				<param type="BrightWire.IMatrix" name="delta" summary="The delta matrix" />
				<param type="BrightWire.ILearningContext" name="context" summary="The graph learning context" />
			</method>
</interface>
<interface name="BrightWire.IGraphData" base="">
	<summary>
		Wrapper around the data that is used as a signal between nodes in the graph
	</summary>
		<property type="System.Int32" name="Rows">
		<summary>Row count</summary>
	</property>
	<property type="System.Int32" name="Columns">
		<summary>Column count</summary>
	</property>
	<property type="System.Int32" name="Depth">
		<summary>3D Tensor depth (1 if the signal is a matrix)</summary>
	</property>
	<property type="System.Int32" name="Count">
		<summary>Count of 3D tensors (1 of the signal is a matrix or 3D tensor)</summary>
	</property>
	<method type="BrightWire.IMatrix" name="GetMatrix">
		<summary>Gets the signal as a matrix</summary>
			</method>
	<method type="BrightWire.I4DTensor" name="Get4DTensor">
		<summary>Gets the signal as a 4D tensor</summary>
			</method>
	<method type="BrightWire.IGraphData" name="ReplaceWith">
		<summary>Replaces the data with the specified matrix (but preserves any tensor meta data)</summary>
				<param type="BrightWire.IMatrix" name="matrix" summary="The matrix to use as a replacement" />
			</method>
	<method type="System.Collections.Generic.IReadOnlyList&lt;BrightWire.IMatrix&gt;" name="GetSubMatrices">
		<summary>Returns the list of matrices that compose the signal (single item if the signal is a matrix)</summary>
			</method>
</interface>
<interface name="BrightWire.IGraphEngine" base="">
	<summary>
		Graph engines drive execution within a graph
	</summary>
		<property type="BrightWire.ILinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary>Linear algebra provider</summary>
	</property>
	<property type="BrightWire.Models.ExecutionGraph" name="Graph">
		<summary>Serialised version of the current graph and its parameters</summary>
	</property>
	<property type="BrightWire.IDataSource" name="DataSource">
		<summary>Data source that feeds into the graph</summary>
	</property>
	<method type="System.Collections.Generic.IReadOnlyList&lt;BrightWire.Models.ExecutionResult&gt;" name="Execute">
		<summary>Executes a data source on the current graph</summary>
				<param type="BrightWire.IDataSource" name="dataSource" summary="Data source to process" />
				<param type="System.Int32" name="batchSize" summary="Initial size of each mini batch" />
				<param type="System.Action&lt;System.Single&gt;" name="batchCompleteCallback" summary="Optional callback to be notifiied after each mini batch has completed" />
			</method>
	<method type="BrightWire.Models.ExecutionResult" name="Execute">
		<summary>Executes a single vector on the current graph</summary>
				<param type="System.Single[]" name="input" summary="Vector to execute" />
			</method>
	<method type="BrightWire.Models.ExecutionResult" name="ExecuteSequential">
		<summary>Executes a sequential input on the current graph</summary>
				<param type="System.Int32" name="sequenceIndex" summary="Index of the current sequence (starting from 0)" />
				<param type="System.Single[]" name="input" summary="Input vector" />
				<param type="BrightWire.IExecutionContext" name="executionContext" summary="Graph execution context" />
				<param type="BrightWire.MiniBatchSequenceType" name="sequenceType" summary="The sequence type (start, standard, end)" />
			</method>
	<property type="BrightWire.INode" name="Start">
		<summary>The graph's single start node</summary>
	</property>
</interface>
<interface name="BrightWire.IGraphOperation" base="">
	<summary>
		A pending graph operation (mini batch)
	</summary>
		<method type="System.Void" name="Execute">
		<summary>Executes the operation</summary>
				<param type="BrightWire.IExecutionContext" name="executionContext" summary="Graph execution context" />
			</method>
</interface>
<interface name="BrightWire.IGraphTrainingEngine" base="BrightWire.IGraphEngine">
	<summary>
		A graph engine that also trains the graph's parameters against training data
	</summary>
		<method type="BrightWire.INode" name="GetInput">
		<summary>Returns the specified input node</summary>
				<param type="System.Int32" name="index" summary="Index of the input node to retrieve" />
			</method>
	<method type="System.Double" name="Train">
		<summary>Executes a training epoch on the graph</summary>
				<param type="BrightWire.IExecutionContext" name="executionContext" summary="Graph execution context" />
				<param type="System.Action&lt;System.Single&gt;" name="batchCompleteCallback" summary="Optional callback to be notifiied after each mini batch has completed" />
			</method>
	<method type="System.Boolean" name="Test">
		<summary>Executes test data on the current graph</summary>
				<param type="BrightWire.IDataSource" name="testDataSource" summary="Data source with test data" />
				<param type="BrightWire.IErrorMetric" name="errorMetric" summary="Error metric to use to evaluate the test score" />
				<param type="System.Int32" name="batchSize" summary="Initial size of each mini batch" />
				<param type="System.Action&lt;System.Single&gt;" name="batchCompleteCallback" summary="Optional callback to be notifiied after each mini batch has completed" />
			</method>
	<property type="BrightWire.ILearningContext" name="LearningContext">
		<summary>Graph learning context</summary>
	</property>
	<method type="System.Void" name="LoadParametersFrom">
		<summary>Loads model parameters into the existing graph</summary>
				<param type="BrightWire.Models.ExecutionGraph" name="graph" summary="Model to load parameters from" />
			</method>
</interface>
<interface name="BrightWire.IHaveAction" base="">
	<summary>
		Node that exposes an action
	</summary>
		<property type="BrightWire.IAction" name="Action">
		<summary>The node's action</summary>
	</property>
</interface>
<interface name="BrightWire.IHaveColumns" base="">
	<summary>
		Column provider
	</summary>
		<property type="System.Collections.Generic.IReadOnlyList&lt;BrightWire.IColumn&gt;" name="Columns">
		<summary>The list of columns</summary>
	</property>
	<property type="System.Int32" name="ColumnCount">
		<summary>The number of columns</summary>
	</property>
</interface>
<interface name="BrightWire.IHaveMemoryNode" base="">
	<summary>
		Nodes that have a memory feeder sub-node
	</summary>
		<property type="BrightWire.INode" name="Memory">
		<summary>The memory feed sub node</summary>
	</property>
</interface>
<interface name="BrightWire.IIndexable3DTensor" base="BrightWire.I3DTensor">
	<summary>
		A 3D tensor that can be directly indexed
	</summary>
		<property type="System.Single" name="this">
		<summary>Returns a value from the tensor</summary>
	</property>
	<property type="System.Collections.Generic.IReadOnlyList&lt;BrightWire.IIndexableMatrix&gt;" name="Matrix">
		<summary>Gets a list of the indexable matrices</summary>
	</property>
</interface>
<interface name="BrightWire.IIndexableMatrix" base="BrightWire.IMatrix">
	<summary>
		A matrix whose elements can be indexed directly
	</summary>
		<property type="System.Single" name="this">
		<summary>Returns an element from the current matrix</summary>
	</property>
	<property type="System.Collections.Generic.IEnumerable&lt;BrightWire.IIndexableVector&gt;" name="Rows">
		<summary>Returns the rows of the current matrix as vectors</summary>
	</property>
	<property type="System.Collections.Generic.IEnumerable&lt;BrightWire.IIndexableVector&gt;" name="Columns">
		<summary>Returns the columns of the current matrix as vectors</summary>
	</property>
	<property type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" name="Values">
		<summary>Returns each element in the current matrix as enumerable</summary>
	</property>
	<method type="BrightWire.IIndexableMatrix" name="Map">
		<summary>Mutates each element of the current matrix</summary>
				<param type="System.Func&lt;System.Single, System.Single&gt;" name="mutator" summary="The function to apply to each element" />
			</method>
	<method type="BrightWire.IIndexableMatrix" name="MapIndexed">
		<summary>Mutates each element of the current matrix</summary>
				<param type="System.Func&lt;System.Int32, System.Int32, System.Single, System.Single&gt;" name="mutator" summary="The function to apply to each element (rowIndex: int, columnIndex: int, value: float) => float" />
			</method>
	<property type="System.String" name="AsXml">
		<summary>Returns the matrix as xml</summary>
	</property>
</interface>
<interface name="BrightWire.IIndexableVector" base="BrightWire.IVector">
	<summary>
		Returns an indexable vector (in which elements can be directly indexed)
	</summary>
		<property type="System.Single" name="this">
		<summary>Returns an element at the specified index</summary>
	</property>
	<property type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" name="Values">
		<summary>Gets the values as an enumerable</summary>
	</property>
	<method type="System.Single[]" name="ToArray">
		<summary>Converts the vector to an array</summary>
			</method>
	<method type="BrightWire.IIndexableVector" name="Append">
		<summary>Creates a new vector (without in place modification) in which new values are appended onto the end of the current vector</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;System.Single&gt;" name="data" summary="The values to append" />
			</method>
</interface>
<interface name="BrightWire.IIndexColumnInfo" base="BrightWire.IColumnInfo">
	<summary>
		Column statistics for index based columns
	</summary>
		<property type="System.UInt32" name="MinIndex">
		<summary>Minimum index</summary>
	</property>
	<property type="System.UInt32" name="MaxIndex">
		<summary>Maximum index</summary>
	</property>
</interface>
<interface name="BrightWire.IIndexListClassifier" base="BrightWire.IRowClassifier">
	<summary>
		A classifier that classifies index lists
	</summary>
		<method type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, System.Single Weight)&gt;" name="Classify">
		<summary>Classifies the input data and returns the classifications with their weights</summary>
				<param type="BrightWire.Models.IndexList" name="indexList" summary="The index list to classify" />
			</method>
</interface>
<interface name="BrightWire.IIndexListEncoder" base="">
	<summary>
		Encodes index lists to dense vectors
	</summary>
		<method type="System.Single[]" name="Encode">
		<summary>Encodes the index lists to a dense vector</summary>
				<param type="BrightWire.Models.IndexList" name="indexList" summary="The index list to encode" />
			</method>
</interface>
<interface name="BrightWire.ILearningContext" base="">
	<summary>
		Graph learning context
	</summary>
		<property type="System.Double" name="EpochSeconds">
		<summary>The duration in seconds of the last epoch</summary>
	</property>
	<property type="System.Int64" name="EpochMilliseconds">
		<summary>The duration in milliseconds of the last epoch</summary>
	</property>
	<property type="BrightWire.ILinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary>The linear algebra provider</summary>
	</property>
	<property type="System.Int32" name="CurrentEpoch">
		<summary>The index of the current epoch (starting from one)</summary>
	</property>
	<property type="System.Single" name="LearningRate">
		<summary>The current learning/training rate</summary>
	</property>
	<property type="System.Single" name="BatchLearningRate">
		<summary>The learning rate adjusted with the current batch size</summary>
	</property>
	<property type="System.Int32" name="BatchSize">
		<summary>The current mini batch size</summary>
	</property>
	<property type="System.Int32" name="RowCount">
		<summary>The total number of rows per epoch</summary>
	</property>
	<method type="System.Void" name="StoreUpdate">
		<summary>Stores an update to the model parameters</summary>
				<param type="BrightWire.INode" name="fromNode" summary="The node that is affected by this update" />
				<param type="T" name="update" summary="The update" />
				<param type="System.Action&lt;T&gt;" name="updater" summary="Callback to execute the update" />
			</method>
	<property type="BrightWire.TrainingErrorCalculation" name="TrainingErrorCalculation">
		<summary>True if the graph should calculate training error</summary>
	</property>
	<property type="System.Boolean" name="DeferUpdates">
		<summary>True if updates are deferred until the mini batch is complete</summary>
	</property>
	<method type="System.Void" name="ApplyUpdates">
		<summary>Apply any deferred updates</summary>
			</method>
	<method type="System.Void" name="StartEpoch">
		<summary>Start a new epoch</summary>
			</method>
	<method type="System.Void" name="EndEpoch">
		<summary>End the current epoch</summary>
			</method>
	<method type="System.Void" name="SetRowCount">
		<summary>Sets the number of rows</summary>
				<param type="System.Int32" name="rowCount" summary="The number of rows per epoch" />
			</method>
	<method type="System.Void" name="DeferBackpropagation">
		<summary>Register the backpropagation to be deferred</summary>
				<param type="BrightWire.IGraphData" name="errorSignal" summary="The error signal associated with this backpropagation (optional, can be null)" />
				<param type="System.Action&lt;BrightWire.IGraphData&gt;" name="update" summary="The callback to execute the backpropagation" />
			</method>
	<method type="System.Void" name="BackpropagateThroughTime">
		<summary>Backpropagates the error signal across all deferred backpropagations</summary>
				<param type="BrightWire.IGraphData" name="signal" summary="The backpropagation signal" />
				<param type="System.Int32" name="maxDepth" summary="The maximum depth to backpropagate the signal" />
			</method>
	<method type="System.Void" name="ScheduleLearningRate">
		<summary>Schedules a change in the learning rate the specified epoch</summary>
				<param type="System.Int32" name="atEpoch" summary="The epoch to change the learning rate" />
				<param type="System.Single" name="newLearningRate" summary="The learning rate to use at that epoch" />
			</method>
	<method type="System.Void" name="EnableNodeUpdates">
		<summary>Enable or disable node parameter updates</summary>
				<param type="BrightWire.INode" name="node" summary="The node to modify" />
				<param type="System.Boolean" name="enableUpdates" summary="True if the node can make updates via backpropagation" />
			</method>
	<method type="System.Void" name="Clear">
		<summary>Resets the learning context</summary>
			</method>
</interface>
<interface name="BrightWire.ILinearAlgebraProvider" base="System.IDisposable">
	<summary>
		Provides linear algebra functionality
	</summary>
		<method type="BrightWire.IVector" name="CreateVector">
		<summary>Creates a vector based on an enumerable of floats</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" name="data" summary="The initial values in the vector" />
			</method>
	<method type="BrightWire.IVector" name="CreateVector">
		<summary>Creates a vector</summary>
				<param type="System.Int32" name="length" summary="Size of the vector" />
				<param type="System.Func&lt;System.Int32, System.Single&gt;" name="init" summary="Callback to initialise each element of the vector" />
			</method>
	<method type="BrightWire.IMatrix" name="CreateMatrix">
		<summary>Creates a matrix</summary>
				<param type="System.Int32" name="rows" summary="The number of rows" />
				<param type="System.Int32" name="columns" summary="The number of columns" />
				<param type="System.Func&lt;System.Int32, System.Int32, System.Single&gt;" name="init" summary="Callback to initialise each element of the matrix" />
			</method>
	<method type="BrightWire.IMatrix" name="CreateMatrix">
		<summary>Creates a matrix from a list of vectors</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;BrightWire.IVector&gt;" name="rows" summary="The list of rows in the new matrix" />
			</method>
	<method type="BrightWire.IMatrix" name="CreateZeroMatrix">
		<summary>Creates a matrix that is initialised to zero</summary>
				<param type="System.Int32" name="rows" summary="The number of rows" />
				<param type="System.Int32" name="columns" summary="The number of columns" />
			</method>
	<method type="BrightWire.IMatrix" name="CreateMatrix">
		<summary>Creates an unitialised matrix (the initial matrix values might be anything)</summary>
				<param type="System.Int32" name="rows" summary="The number of rows" />
				<param type="System.Int32" name="columns" summary="The number of columns" />
			</method>
	<method type="BrightWire.I3DTensor" name="Create3DTensor">
		<summary>Creates a 3D tensor</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;BrightWire.IMatrix&gt;" name="data" summary="The list of matrices that form the 3D tensor" />
			</method>
	<method type="BrightWire.I4DTensor" name="Create4DTensor">
		<summary>Creates a 4D tensor</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;BrightWire.Models.FloatTensor&gt;" name="data" summary="The list of 3D tensors that form the 4D tensor" />
			</method>
	<method type="BrightWire.I4DTensor" name="Create4DTensor">
		<summary>Creates a 4D tensor</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;BrightWire.I3DTensor&gt;" name="tensorList" summary="The list of 3D tensors that form the 4D tensor" />
			</method>
	<method type="System.Void" name="PushLayer">
		<summary>Creates a save point in the allocation history</summary>
			</method>
	<method type="System.Void" name="PopLayer">
		<summary>Releases all allocated memory since the last save point</summary>
			</method>
	<property type="System.Boolean" name="IsStochastic">
		<summary>Underlying setting for stochastic vs deterministic behaviour across BrightWire</summary>
	</property>
	<property type="System.Boolean" name="IsGpu">
		<summary>True if the provider uses the GPU</summary>
	</property>
</interface>
<interface name="BrightWire.ILinearRegressionPredictor" base="System.IDisposable">
	<summary>
		Linear regression predictor
	</summary>
		<method type="System.Single" name="Predict">
		<summary>Predicts a value from input data</summary>
				<param type="System.Single[]" name="vals" summary="The input data" />
			</method>
	<method type="System.Single" name="Predict">
		<summary>Predicts a value from input data</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;System.Single&gt;" name="vals" summary="The input data" />
			</method>
	<method type="System.Single[]" name="Predict">
		<summary>Bulk value prediction</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;System.Collections.Generic.IReadOnlyList&lt;System.Single&gt;&gt;" name="input" summary="List of data to predict" />
			</method>
</interface>
<interface name="BrightWire.ILinearRegressionTrainer" base="">
	<summary>
		Trainer for linear regression models
	</summary>
		<method type="BrightWire.Models.LinearRegression" name="GradientDescent">
		<summary>Solves the model using gradient descent</summary>
				<param type="System.Int32" name="iterations" summary="Number of training epochs" />
				<param type="System.Single" name="learningRate" summary="The training rate" />
				<param type="System.Single" name="lambda" summary="Regularisation lambda" />
				<param type="System.Func&lt;System.Single, System.Boolean&gt;" name="costCallback" summary="Callback with current cost - False to stop training" />
			</method>
	<method type="System.Single" name="ComputeCost">
		<summary>Computes the cost of the specified parameters</summary>
				<param type="BrightWire.IVector" name="theta" summary="The model parameters" />
				<param type="System.Single" name="lambda" summary="Regularisation lambda" />
			</method>
</interface>
<interface name="BrightWire.ILogisticRegressionClassifier" base="System.IDisposable">
	<summary>
		Logistic regression classifier
	</summary>
		<method type="System.Single" name="Predict">
		<summary>Outputs a value from 0 to 1</summary>
				<param type="System.Single[]" name="vals" summary="Input data" />
			</method>
	<method type="System.Single" name="Predict">
		<summary>Outputs a value from 0 to 1</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;System.Single&gt;" name="vals" summary="Input data" />
			</method>
	<method type="System.Single[]" name="Predict">
		<summary>Outputs a list of values from 0 to 1 for each input data</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;System.Collections.Generic.IReadOnlyList&lt;System.Single&gt;&gt;" name="input" summary="Input data" />
			</method>
</interface>
<interface name="BrightWire.ILogisticRegressionTrainer" base="">
	<summary>
		A logistic regression trainer
	</summary>
		<method type="BrightWire.Models.LogisticRegression" name="GradientDescent">
		<summary>Trains a model using gradient descent</summary>
				<param type="System.Int32" name="iterations" summary="Number of training epochs" />
				<param type="System.Single" name="learningRate" summary="The training rate" />
				<param type="System.Single" name="lambda" summary="Regularisation lambda" />
				<param type="System.Func&lt;System.Single, System.Boolean&gt;" name="costCallback" summary="Callback with current cost - False to stop training" />
			</method>
	<method type="System.Single" name="ComputeCost">
		<summary>Computes the cost of the specified parameters</summary>
				<param type="BrightWire.IVector" name="theta" summary="The model parameters" />
				<param type="System.Single" name="lambda" summary="Regularisation lambda" />
			</method>
</interface>
<interface name="BrightWire.IMarkovModelTrainer&lt;T&gt;" base="BrightWire.ICanSerialiseToStream">
	<summary>
		Markov model trainer
	</summary>
		<method type="System.Void" name="Add">
		<summary>Adds a sequence of items to the trainer</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="items" summary="" />
			</method>
</interface>
<interface name="BrightWire.IMarkovModelTrainer2&lt;T&gt;" base="BrightWire.IMarkovModelTrainer&lt;T&gt;">
	<summary>
		Markov model trainer (window size 2)
	</summary>
		<method type="BrightWire.Models.Bayesian.MarkovModel2&lt;T&gt;" name="Build">
		<summary>Gets all current observations</summary>
			</method>
</interface>
<interface name="BrightWire.IMarkovModelTrainer3&lt;T&gt;" base="BrightWire.IMarkovModelTrainer&lt;T&gt;">
	<summary>
		Markov model trainer (window size 3)
	</summary>
		<method type="BrightWire.Models.Bayesian.MarkovModel3&lt;T&gt;" name="Build">
		<summary>Gets all current observations</summary>
			</method>
</interface>
<interface name="BrightWire.IMatrix" base="System.IDisposable">
	<summary>
		A matrix
	</summary>
		<property type="System.Boolean" name="IsValid">
		<summary>Checks if the matrix has not been disposed</summary>
	</property>
	<method type="BrightWire.IMatrix" name="Multiply">
		<summary>Multiplies the current vector (without in place modification) with the target matrix</summary>
				<param type="BrightWire.IMatrix" name="matrix" summary="The target matrix" />
			</method>
	<property type="System.Int32" name="ColumnCount">
		<summary>The number of columns</summary>
	</property>
	<property type="System.Int32" name="RowCount">
		<summary>The number of rows</summary>
	</property>
	<method type="BrightWire.IVector" name="Column">
		<summary>Returns a column as a vector</summary>
				<param type="System.Int32" name="index" summary="The column index" />
			</method>
	<method type="BrightWire.IVector" name="Diagonal">
		<summary>Returns the matrix diagonal as a vector</summary>
			</method>
	<method type="BrightWire.IVector" name="Row">
		<summary>Returns a row as a vector</summary>
				<param type="System.Int32" name="index" summary="The row index" />
			</method>
	<method type="BrightWire.IMatrix" name="Add">
		<summary>Returns the current matrix (without in place modification) added to the target matrix</summary>
				<param type="BrightWire.IMatrix" name="matrix" summary="The target matrix" />
			</method>
	<method type="BrightWire.IMatrix" name="Subtract">
		<summary>Returns the current matrix  (without in place modification) minus the target matrix</summary>
				<param type="BrightWire.IMatrix" name="matrix" summary="The target matrix" />
			</method>
	<method type="BrightWire.IMatrix" name="PointwiseMultiply">
		<summary>Returns the pointwise product of the current matrix (without in place modification) with the target matrix</summary>
				<param type="BrightWire.IMatrix" name="matrix" summary="The target matrix" />
			</method>
	<method type="BrightWire.IMatrix" name="TransposeAndMultiply">
		<summary>Returns the current matrix (without in place modification) and multipled with the transposed target matrix</summary>
				<param type="BrightWire.IMatrix" name="matrix" summary="The target matrix" />
			</method>
	<method type="BrightWire.IMatrix" name="TransposeThisAndMultiply">
		<summary>Returns the transpose of the current matrix (without in place modification) multipled with the target matrix</summary>
				<param type="BrightWire.IMatrix" name="matrix" summary="" />
			</method>
	<method type="BrightWire.IVector" name="RowSums">
		<summary>Returns a vector that contains the sum of the elements in each row of the current matrix</summary>
			</method>
	<method type="BrightWire.IVector" name="ColumnSums">
		<summary>Returns a vector that contains the sum of the elements in each column of the current matrix</summary>
			</method>
	<method type="BrightWire.IMatrix" name="Transpose">
		<summary>Returns the transpose of the current matrix</summary>
			</method>
	<method type="System.Void" name="Multiply">
		<summary>Multiplies (in place) each element of the matrix by a scalar</summary>
				<param type="System.Single" name="scalar" summary="The scalar to multiply each element" />
			</method>
	<method type="BrightWire.IMatrix" name="Multiply">
		<summary>Returns the product of the current matrix (without in place modification) with the target vector</summary>
				<param type="BrightWire.IVector" name="vector" summary="The target vector" />
			</method>
	<method type="System.Void" name="AddInPlace">
		<summary>Adds the target matrix to the current matrix (in place)</summary>
				<param type="BrightWire.IMatrix" name="matrix" summary="The target matrix" />
				<param type="System.Single" name="coefficient1" summary="A coefficient to multiply each element of the current matrix" />
				<param type="System.Single" name="coefficient2" summary="A coefficient to multipy each element of the target matrix" />
			</method>
	<method type="System.Void" name="SubtractInPlace">
		<summary>Subtracts the target matrix from the current matrix (in place)</summary>
				<param type="BrightWire.IMatrix" name="matrix" summary="The target matrix" />
				<param type="System.Single" name="coefficient1" summary="A coefficient to multiply each element of the current matrix" />
				<param type="System.Single" name="coefficient2" summary="A coefficient to multipy each element of the target matrix" />
			</method>
	<method type="BrightWire.IMatrix" name="SigmoidActivation">
		<summary>Returns a new matrix with the sigmoid function applied to each element</summary>
			</method>
	<method type="BrightWire.IMatrix" name="SigmoidDerivative">
		<summary>Returns a new matrix with the sigmoid derivative of each element</summary>
			</method>
	<method type="BrightWire.IMatrix" name="TanhActivation">
		<summary>Returns a new matrix with the tanh function applied to each element</summary>
			</method>
	<method type="BrightWire.IMatrix" name="TanhDerivative">
		<summary>Returns a new matrix with the tanh derivative of each element</summary>
			</method>
	<method type="BrightWire.IMatrix" name="SoftmaxActivation">
		<summary>Returns a new matrix with the softmax function applied to each row of the matrix</summary>
			</method>
	<method type="System.Void" name="AddToEachRow">
		<summary>Adds the target vector to each row of the current matrix (in place)</summary>
				<param type="BrightWire.IVector" name="vector" summary="The target vector" />
			</method>
	<method type="System.Void" name="AddToEachColumn">
		<summary>Adds the target vector to each column of the current matrix (in place)</summary>
				<param type="BrightWire.IVector" name="vector" summary="The target vector" />
			</method>
	<property type="BrightWire.Models.FloatMatrix" name="Data">
		<summary>Converts the current matrix to protobuf format</summary>
	</property>
	<method type="BrightWire.IIndexableMatrix" name="AsIndexable">
		<summary>Converts the matrix to an indexable matrix</summary>
			</method>
	<method type="BrightWire.IMatrix" name="GetNewMatrixFromRows">
		<summary>Returns a new matrix from a subset of the current matrix's rows</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;System.Int32&gt;" name="rowIndexes" summary="The list of row indices" />
			</method>
	<method type="BrightWire.IMatrix" name="GetNewMatrixFromColumns">
		<summary>Returns a new matrix from a subset of the current matrix's columns</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;System.Int32&gt;" name="columnIndexes" summary="The list of column indices" />
			</method>
	<method type="System.Void" name="ClearRows">
		<summary>Set to zero the specified rows in the current matrix</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;System.Int32&gt;" name="indexes" summary="The list of row indices" />
			</method>
	<method type="System.Void" name="ClearColumns">
		<summary>Set to zero the specified columns in the current matrix</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;System.Int32&gt;" name="indexes" summary="The list of column indices" />
			</method>
	<method type="BrightWire.IMatrix" name="ReluActivation">
		<summary>Returns the RELU function applied to each element of the current matrix</summary>
			</method>
	<method type="BrightWire.IMatrix" name="ReluDerivative">
		<summary>Returns the RELU derivative of each element in the current matrix</summary>
			</method>
	<method type="BrightWire.IMatrix" name="LeakyReluActivation">
		<summary>Returns the leaky RELU function applied to each element in the current matrix</summary>
			</method>
	<method type="BrightWire.IMatrix" name="LeakyReluDerivative">
		<summary>Returns the leaky RELU derivative of each element in the current matrix</summary>
			</method>
	<method type="BrightWire.IMatrix" name="Clone">
		<summary>Creates a copy of the current matrix</summary>
			</method>
	<method type="System.Void" name="Clear">
		<summary>Sets each element to zero</summary>
			</method>
	<method type="BrightWire.IMatrix" name="Sqrt">
		<summary>Returns the square root of each element in the current matrix</summary>
				<param type="System.Single" name="valueAdjustment" summary="Term to add to each element in the result matrix" />
			</method>
	<method type="BrightWire.IMatrix" name="Pow">
		<summary>Returns each element raised to specified power</summary>
				<param type="System.Single" name="power" summary="The power to apply to each element" />
			</method>
	<method type="BrightWire.IMatrix" name="PointwiseDivide">
		<summary>Returns the current matrix (not modified in place) divided by the target matrix</summary>
				<param type="BrightWire.IMatrix" name="matrix" summary="The target matrix" />
			</method>
	<method type="System.Void" name="L1Regularisation">
		<summary>L1 Regularisation applied to each element of the current matrix (in place)</summary>
				<param type="System.Single" name="coefficient" summary="The L1 coefficient" />
			</method>
	<method type="BrightWire.IVector" name="ColumnL2Norm">
		<summary>Returns a vector of the L2 norms of each column</summary>
			</method>
	<method type="BrightWire.IVector" name="RowL2Norm">
		<summary>Returns a vector of the L2 norms of each row</summary>
			</method>
	<method type="System.Void" name="PointwiseDivideRows">
		<summary>Pointwise divide each row by the target vector (in place)</summary>
				<param type="BrightWire.IVector" name="vector" summary="The target vector" />
			</method>
	<method type="System.Void" name="PointwiseDivideColumns">
		<summary>Pointwise divide each column by the target vector (in place)</summary>
				<param type="BrightWire.IVector" name="vector" summary="The target vector" />
			</method>
	<method type="System.Void" name="Constrain">
		<summary>Constrain each value within the specified min and max values (in place)</summary>
				<param type="System.Single" name="min" summary="The minimum allowed value" />
				<param type="System.Single" name="max" summary="The maximum allowed value" />
			</method>
	<method type="BrightWire.IVector" name="GetRowSegment">
		<summary>Returns a segment from a row of the current matrix</summary>
				<param type="System.Int32" name="rowIndex" summary="The row index" />
				<param type="System.Int32" name="columnIndex" summary="The start index to return" />
				<param type="System.Int32" name="length" summary="The number of elements to return" />
			</method>
	<method type="BrightWire.IVector" name="GetColumnSegment">
		<summary>Returns a segment from a column of the current matrix</summary>
				<param type="System.Int32" name="columnIndex" summary="The column index" />
				<param type="System.Int32" name="rowIndex" summary="The start index to return" />
				<param type="System.Int32" name="length" summary="The number of elements to return" />
			</method>
	<method type="BrightWire.IMatrix" name="ConcatColumns">
		<summary>Returns a new matrix with the columns of the target matrix appended to each column of the current matrix</summary>
				<param type="BrightWire.IMatrix" name="bottom" summary="The target matrix" />
			</method>
	<method type="BrightWire.IMatrix" name="ConcatRows">
		<summary>Returns a new matrix with the rows of the target matrix appended to each row of the current matrix</summary>
				<param type="BrightWire.IMatrix" name="right" summary="The target matrix" />
			</method>
	<method type="(BrightWire.IMatrix Left, BrightWire.IMatrix Right)" name="SplitAtColumn">
		<summary>Splits the rows of the current matrix into two matrices</summary>
				<param type="System.Int32" name="columnIndex" summary="The column index at which to split" />
			</method>
	<method type="(BrightWire.IMatrix Top, BrightWire.IMatrix Bottom)" name="SplitAtRow">
		<summary>Splits the columns of the current matrix into two matrices</summary>
				<param type="System.Int32" name="rowIndex" summary="The row index at which to split" />
			</method>
	<method type="(BrightWire.IMatrix U, BrightWire.IVector S, BrightWire.IMatrix VT)" name="Svd">
		<summary>Singular value decomposition</summary>
			</method>
	<method type="BrightWire.IVector" name="ConvertInPlaceToVector">
		<summary>Fast conversion to vector (the internal buffer is not modified)</summary>
			</method>
	<method type="BrightWire.I3DTensor" name="ConvertTo3DTensor">
		<summary>Converts the matrix to a 3D tensor</summary>
				<param type="System.Int32" name="rows" summary="Tensor row count" />
				<param type="System.Int32" name="columns" summary="Tensor column count" />
			</method>
	<method type="BrightWire.I4DTensor" name="ConvertTo4DTensor">
		<summary>Converts the matrix to a 4D tensor</summary>
				<param type="System.Int32" name="rows" summary="Tensor row count" />
				<param type="System.Int32" name="columns" summary="Tensor column count" />
				<param type="System.Int32" name="depth" summary="Tensor depth" />
			</method>
</interface>
<interface name="BrightWire.IMiniBatch" base="">
	<summary>
		Mini batch
	</summary>
		<property type="System.Collections.Generic.IReadOnlyList&lt;System.Int32&gt;" name="Rows">
		<summary>Row indexes of the current batch</summary>
	</property>
	<property type="BrightWire.IDataSource" name="DataSource">
		<summary>Data source</summary>
	</property>
	<property type="System.Boolean" name="IsSequential">
		<summary>True if the data is sequential</summary>
	</property>
	<property type="System.Int32" name="BatchSize">
		<summary>Number of items in the batch</summary>
	</property>
	<property type="BrightWire.IMiniBatchSequence" name="CurrentSequence">
		<summary>Current sequence (non sequential batches have a single sequence)</summary>
	</property>
	<property type="System.Boolean" name="HasNextSequence">
		<summary>True if there is another item in the sequence after the current item</summary>
	</property>
	<method type="BrightWire.IMiniBatchSequence" name="GetNextSequence">
		<summary>Gets the next item in the sequence</summary>
			</method>
	<property type="System.Int32" name="SequenceCount">
		<summary>Gets the length of the sequence</summary>
	</property>
	<method type="BrightWire.IMiniBatchSequence" name="GetSequenceAtIndex">
		<summary>Gets a sequence item</summary>
				<param type="System.Int32" name="index" summary="The index to retrieve" />
			</method>
	<method type="System.Void" name="Reset">
		<summary>Resets the sequence iterator</summary>
			</method>
</interface>
<interface name="BrightWire.IMiniBatchSequence" base="">
	<summary>
		A sequence within a mini batch
	</summary>
		<property type="BrightWire.IMiniBatch" name="MiniBatch">
		<summary>Mini batch</summary>
	</property>
	<property type="System.Int32" name="SequenceIndex">
		<summary>Index of the sequence</summary>
	</property>
	<property type="BrightWire.MiniBatchSequenceType" name="Type">
		<summary>Sequence type</summary>
	</property>
	<property type="System.Collections.Generic.IReadOnlyList&lt;BrightWire.IGraphData&gt;" name="Input">
		<summary>Input data</summary>
	</property>
	<property type="BrightWire.IGraphData" name="Target">
		<summary>Training target data</summary>
	</property>
</interface>
<interface name="BrightWire.INode" base="BrightWire.ICanInitialiseNode">
	<summary>
		Graph node
	</summary>
		<property type="System.String" name="Id">
		<summary>Unique id</summary>
	</property>
	<property type="System.String" name="Name">
		<summary>Friendly name</summary>
	</property>
	<property type="System.Collections.Generic.List&lt;BrightWire.IWire&gt;" name="Output">
		<summary>List of outgoing wires</summary>
	</property>
	<method type="System.Void" name="ExecuteForward">
		<summary>Executes the node forward</summary>
				<param type="BrightWire.IContext" name="context" summary="Graph context" />
				<param type="System.Int32" name="channel" summary="Channel the signal was received on" />
			</method>
	<method type="BrightWire.INode" name="FindByName">
		<summary>Searches for a node by friendly name</summary>
				<param type="System.String" name="name" summary="Friendly name of the node to find" />
			</method>
	<method type="BrightWire.INode" name="FindById">
		<summary>Searches for a node by id</summary>
				<param type="System.String" name="id" summary="Unique id of the node" />
			</method>
	<property type="System.Collections.Generic.IEnumerable&lt;BrightWire.INode&gt;" name="SubNodes">
		<summary>Sub-nodes of the current node</summary>
	</property>
	<method type="BrightWire.Models.ExecutionGraph.Node" name="SerialiseTo">
		<summary>Serialise the node</summary>
				<param type="System.Collections.Generic.HashSet&lt;BrightWire.INode&gt;" name="existing" summary="Set of nodes that have already been serialised in the current context" />
				<param type="System.Collections.Generic.List&lt;BrightWire.Models.ExecutionGraph.Node&gt;" name="connectedTo" summary="List of nodes this node is connected to" />
				<param type="System.Collections.Generic.HashSet&lt;BrightWire.Models.ExecutionGraph.Wire&gt;" name="wireList" summary="List of wires between all connected nodes" />
			</method>
	<method type="System.Void" name="OnDeserialise">
		<summary>Called after the graph has been completely deserialised</summary>
				<param type="System.Collections.Generic.IReadOnlyDictionary&lt;System.String, BrightWire.INode&gt;" name="graph" summary="Dictionary of nodes with their associated unique ids" />
			</method>
	<method type="System.Void" name="LoadParameters">
		<summary>Loads parameters into an existing node</summary>
				<param type="BrightWire.Models.ExecutionGraph.Node" name="nodeData" summary="Serialised node parameters" />
			</method>
</interface>
<interface name="BrightWire.INumericColumnInfo" base="BrightWire.IColumnInfo">
	<summary>
		Column statistics for a numeric column
	</summary>
		<property type="System.Double" name="Min">
		<summary>The minimum value</summary>
	</property>
	<property type="System.Double" name="Max">
		<summary>The maximum value</summary>
	</property>
	<property type="System.Double" name="Mean">
		<summary>The mean (or average)</summary>
	</property>
	<property type="System.Nullable&lt;System.Double&gt;" name="StdDev">
		<summary>The standard deviation</summary>
	</property>
	<property type="System.Nullable&lt;System.Double&gt;" name="Median">
		<summary>The median value</summary>
	</property>
	<property type="System.Nullable&lt;System.Double&gt;" name="Mode">
		<summary>The mode</summary>
	</property>
	<property type="System.Double" name="L1Norm">
		<summary>The L1 Norm</summary>
	</property>
	<property type="System.Double" name="L2Norm">
		<summary>The L2 Norm</summary>
	</property>
</interface>
<interface name="BrightWire.IPropertySet" base="">
	<summary>
		The current set of graph initialisation parameters
	</summary>
		<property type="BrightWire.ILinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary>The linear algebra provider to use</summary>
	</property>
	<property type="BrightWire.IWeightInitialisation" name="WeightInitialisation">
		<summary>The weight initialiser to use</summary>
	</property>
	<property type="BrightWire.IGradientDescentOptimisation" name="GradientDescent">
		<summary>The gradient descent optimisation to use</summary>
	</property>
	<property type="BrightWire.ICreateTemplateBasedGradientDescent" name="TemplateGradientDescentDescriptor">
		<summary>The template based gradient descent optimisation to use</summary>
	</property>
	<property type="BrightWire.ICreateGradientDescent" name="GradientDescentDescriptor">
		<summary>The descriptor to create new gradient descent optimisations</summary>
	</property>
	<method type="BrightWire.IPropertySet" name="Use">
		<summary>Use the specified template based gradient descent optimisation</summary>
				<param type="BrightWire.ICreateTemplateBasedGradientDescent" name="descriptor" summary="" />
			</method>
	<method type="BrightWire.IPropertySet" name="Use">
		<summary>Use the specified gradient descent optimisation</summary>
				<param type="BrightWire.ICreateGradientDescent" name="descriptor" summary="" />
			</method>
	<method type="BrightWire.IPropertySet" name="Use">
		<summary>Use the specified gradient descent optimisation</summary>
				<param type="BrightWire.IGradientDescentOptimisation" name="optimisation" summary="" />
			</method>
	<method type="BrightWire.IPropertySet" name="Use">
		<summary>Use the specified weight initialiser</summary>
				<param type="BrightWire.IWeightInitialisation" name="weightInit" summary="" />
			</method>
	<method type="BrightWire.IPropertySet" name="Clone">
		<summary>Clones the current property set</summary>
			</method>
	<method type="T" name="Get">
		<summary>Gets a named property</summary>
				<param type="System.String" name="name" summary="The property name" />
				<param type="T" name="defaultValue" summary="The value to use if the property has not been supplied" />
			</method>
	<method type="BrightWire.IPropertySet" name="Set">
		<summary>Sets a named property</summary>
				<param type="System.String" name="name" summary="The property name" />
				<param type="T" name="obj" summary="The property value" />
			</method>
	<method type="System.Void" name="Clear">
		<summary>Clears the named property</summary>
				<param type="System.String" name="name" summary="The property name" />
			</method>
</interface>
<interface name="BrightWire.IRandomProjection" base="System.IDisposable">
	<summary>
		Random projection
	</summary>
		<property type="System.Int32" name="Size">
		<summary>The size to reduce to</summary>
	</property>
	<property type="BrightWire.IMatrix" name="Matrix">
		<summary>The transformation matrix</summary>
	</property>
	<method type="BrightWire.IVector" name="Compute">
		<summary>Reduces a vector</summary>
				<param type="BrightWire.IVector" name="vector" summary="" />
			</method>
	<method type="BrightWire.IMatrix" name="Compute">
		<summary>Reduces a matrix</summary>
				<param type="BrightWire.IMatrix" name="matrix" summary="" />
			</method>
</interface>
<interface name="BrightWire.IRow" base="">
	<summary>
		A data table row
	</summary>
		<property type="System.Int32" name="Index">
		<summary>The index of this row within the data table</summary>
	</property>
	<property type="System.Collections.Generic.IReadOnlyList&lt;System.Object&gt;" name="Data">
		<summary>Gets the raw data from the row</summary>
	</property>
	<method type="T" name="GetField">
		<summary>Gets the value of the specified column (converted to T)</summary>
				<param type="System.Int32" name="index" summary="The column index to query" />
			</method>
	<method type="System.Collections.Generic.IReadOnlyList&lt;T&gt;" name="GetFields">
		<summary>Gets the specified strongly typed values</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;System.Int32&gt;" name="indices" summary="The column indices to return" />
			</method>
	<property type="BrightWire.IHaveColumns" name="Table">
		<summary>Returns the column information</summary>
	</property>
</interface>
<interface name="BrightWire.IRowClassifier" base="">
	<summary>
		A classifier that classifies a data table row
	</summary>
		<method type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, System.Single Weight)&gt;" name="Classify">
		<summary>Classifies the input data and returns the classifications with their weights</summary>
				<param type="BrightWire.IRow" name="row" summary="The row to classify" />
			</method>
</interface>
<interface name="BrightWire.IRowEncoder" base="">
	<summary>
		Encodes data table rows to dense vectors
	</summary>
		<method type="System.Single[]" name="Encode">
		<summary>Encodes a data table row to a dense vector</summary>
				<param type="BrightWire.IRow" name="row" summary="The row to encode" />
			</method>
</interface>
<interface name="BrightWire.IRowProcessor" base="">
	<summary>
		Row processor
	</summary>
		<method type="System.Boolean" name="Process">
		<summary>Will be called for each row</summary>
				<param type="BrightWire.IRow" name="row" summary="The current row" />
			</method>
</interface>
<interface name="BrightWire.IStringColumnInfo" base="BrightWire.IColumnInfo">
	<summary>
		Column statistics for a string based column
	</summary>
		<property type="System.Int32" name="MinLength">
		<summary>The minimum string length</summary>
	</property>
	<property type="System.Int32" name="MaxLength">
		<summary>The maximum string length</summary>
	</property>
	<property type="System.String" name="MostCommonString">
		<summary>The most common string</summary>
	</property>
</interface>
<interface name="BrightWire.IVector" base="System.IDisposable">
	<summary>
		A vector
	</summary>
		<property type="System.Boolean" name="IsValid">
		<summary>Checks if the vector has not been disposed</summary>
	</property>
	<method type="BrightWire.IMatrix" name="ToColumnMatrix">
		<summary>Converts the vector to a column matrix</summary>
			</method>
	<method type="BrightWire.IMatrix" name="ToRowMatrix">
		<summary>Converts the vector to a row matrix</summary>
			</method>
	<property type="System.Int32" name="Count">
		<summary>The number of elements in the vector</summary>
	</property>
	<property type="BrightWire.Models.FloatVector" name="Data">
		<summary>Converts the vector into protobuf format</summary>
	</property>
	<method type="BrightWire.IVector" name="Add">
		<summary>Adds a vector (without in place modification)</summary>
				<param type="BrightWire.IVector" name="vector" summary="The vector to add" />
			</method>
	<method type="BrightWire.IVector" name="Subtract">
		<summary>Subtracts a vector (without in place modification)</summary>
				<param type="BrightWire.IVector" name="vector" summary="The vector to subtract" />
			</method>
	<method type="System.Single" name="L1Norm">
		<summary>Calculates the absolute values (L1) norm: https://en.wikipedia.org/wiki/Norm_(mathematics)</summary>
			</method>
	<method type="System.Single" name="L2Norm">
		<summary>Calculates the euclidean (L2) norm: https://en.wikipedia.org/wiki/Norm_(mathematics)</summary>
			</method>
	<method type="System.Int32" name="MaximumIndex">
		<summary>Returns the index of the vector with the greatest value</summary>
			</method>
	<method type="System.Int32" name="MinimumIndex">
		<summary>Returns the index of the vector with the smallest value</summary>
			</method>
	<method type="System.Void" name="Multiply">
		<summary>Multiples (in place) by a scalar</summary>
				<param type="System.Single" name="scalar" summary="The value to multiple each element" />
			</method>
	<method type="System.Void" name="Add">
		<summary>Adds (in place) a scalar</summary>
				<param type="System.Single" name="scalar" summary="The value to add to each element" />
			</method>
	<method type="System.Void" name="AddInPlace">
		<summary>Adds a vector in place</summary>
				<param type="BrightWire.IVector" name="vector" summary="The target vector to add to the current vector" />
				<param type="System.Single" name="coefficient1" summary="A value to multiply each element of the current vector" />
				<param type="System.Single" name="coefficient2" summary="A value to multiply each element of the target vector" />
			</method>
	<method type="System.Void" name="SubtractInPlace">
		<summary>Subtracts a vector in place</summary>
				<param type="BrightWire.IVector" name="vector" summary="The target vector to subtract from the current vector" />
				<param type="System.Single" name="coefficient1" summary="A value to multiply each element of the current vector" />
				<param type="System.Single" name="coefficient2" summary="A value to multiply each element of the target vector" />
			</method>
	<method type="BrightWire.IIndexableVector" name="AsIndexable">
		<summary>Converts the vector to an indexable vector</summary>
			</method>
	<method type="BrightWire.IVector" name="PointwiseMultiply">
		<summary>Pointwise multiplication (without in place modification) with a vector</summary>
				<param type="BrightWire.IVector" name="vector" summary="" />
			</method>
	<method type="System.Single" name="DotProduct">
		<summary>The dot product of two vectors</summary>
				<param type="BrightWire.IVector" name="vector" summary="The target vector" />
			</method>
	<method type="BrightWire.IVector" name="GetNewVectorFromIndexes">
		<summary>Returns a new vector from a subset of the vector indices</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;System.Int32&gt;" name="indices" summary="A list of indexes to use as the source of the new vector" />
			</method>
	<method type="BrightWire.IVector" name="Clone">
		<summary>Creates a new copy of the vector</summary>
			</method>
	<method type="BrightWire.IVector" name="Sqrt">
		<summary>Creates a new vector in which each element is the square root of the current vector</summary>
			</method>
	<method type="BrightWire.IVector" name="Abs">
		<summary>Creates a new vector in which each element is the absolute value of the current vector</summary>
			</method>
	<method type="System.Void" name="CopyFrom">
		<summary>Copies values from the target vector into the current vector</summary>
				<param type="BrightWire.IVector" name="vector" summary="" />
			</method>
	<method type="System.Single" name="EuclideanDistance">
		<summary>Calculates the euclidean distance between the current and the target vector</summary>
				<param type="BrightWire.IVector" name="vector" summary="The target vector" />
			</method>
	<method type="System.Single" name="CosineDistance">
		<summary>Calculates the cosine distance between the current and the target vector</summary>
				<param type="BrightWire.IVector" name="vector" summary="The target vector>" />
			</method>
	<method type="System.Single" name="ManhattanDistance">
		<summary>Calculates the manhattan distance between the current and the target vector</summary>
				<param type="BrightWire.IVector" name="vector" summary="The target vector" />
			</method>
	<method type="System.Single" name="MeanSquaredDistance">
		<summary>Calculates the mean squared distance between the current and the target vector</summary>
				<param type="BrightWire.IVector" name="vector" summary="The target vector" />
			</method>
	<method type="System.Single" name="SquaredEuclidean">
		<summary>Calculates the squared euclidean distance between the current and the target vector</summary>
				<param type="BrightWire.IVector" name="vector" summary="The target vector" />
			</method>
	<method type="(System.Single Min, System.Single Max)" name="GetMinMax">
		<summary>Finds the minimum and maximum values in the current vector</summary>
			</method>
	<method type="System.Single" name="Average">
		<summary>Calculates the average value from the elements of the current vector</summary>
			</method>
	<method type="System.Single" name="StdDev">
		<summary>Calculates the standard deviation from the elements of the current vector</summary>
				<param type="System.Nullable&lt;System.Single&gt;" name="mean" summary="(optional) pre calculated mean" />
			</method>
	<method type="System.Void" name="Normalise">
		<summary>Normalises (in place) the values of the current vector</summary>
				<param type="BrightWire.NormalisationType" name="type" summary="The type of normalisation" />
			</method>
	<method type="BrightWire.IVector" name="Softmax">
		<summary>Returns the softmax function (without in place modification) applied to the current vector
https://en.wikipedia.org/wiki/Softmax_function</summary>
			</method>
	<method type="BrightWire.IMatrix" name="SoftmaxDerivative">
		<summary>Returns the jacobian matrix of the softmax derivative</summary>
			</method>
	<method type="BrightWire.IVector" name="FindDistances">
		<summary>Returns a vector of distances between the current and target vectors</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;BrightWire.IVector&gt;" name="data" summary="The list of target vectors" />
				<param type="BrightWire.DistanceMetric" name="distance" summary="The distance metric" />
			</method>
	<method type="System.Single" name="FindDistance">
		<summary>Returns the distance between the current and the target vector</summary>
				<param type="BrightWire.IVector" name="other" summary="The target vector" />
				<param type="BrightWire.DistanceMetric" name="distance" summary="The distance metric" />
			</method>
	<method type="BrightWire.IVector" name="CosineDistance">
		<summary>Returns a vector of the cosine distance between the current and target vectors</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;BrightWire.IVector&gt;" name="data" summary="The list of target vectors" />
				<param type="System.Single[]" name="dataNorm" summary="A buffer to hold the norms of the target vectors" />
			</method>
	<method type="BrightWire.IVector" name="Log">
		<summary>Returns a vector (without in place modification) in which each element is the natural log of each element in the current vector</summary>
			</method>
	<method type="BrightWire.IVector" name="Sigmoid">
		<summary>Returns the sigmoid function (without in place modification) applied to the current vector</summary>
			</method>
	<method type="BrightWire.IMatrix" name="ConvertInPlaceToMatrix">
		<summary>Fast conversion to matrix (internal buffer is used directly)</summary>
				<param type="System.Int32" name="rows" summary="The number of rows in the matrix" />
				<param type="System.Int32" name="columns" summary="The number of columns in the matrix" />
			</method>
	<method type="BrightWire.I3DTensor" name="ConvertTo3DTensor">
		<summary>Converts the vector to a tensor</summary>
				<param type="System.Int32" name="rows" summary="Number of rows in tensor" />
				<param type="System.Int32" name="columns" summary="Number of columns in tensor" />
				<param type="System.Int32" name="depth" summary="Depth of the tensor" />
			</method>
	<method type="System.Collections.Generic.IReadOnlyList&lt;BrightWire.IVector&gt;" name="Split">
		<summary>Splits the vector into a list of vectors</summary>
				<param type="System.Int32" name="blockCount" summary="The number of sub vectors to split into" />
			</method>
	<method type="BrightWire.IVector" name="Rotate">
		<summary>Rotates values in the vector (both within and along blocks)</summary>
				<param type="System.Int32" name="blockCount" summary="The size of each sub vector" />
			</method>
	<method type="BrightWire.IVector" name="Reverse">
		<summary>In place reversal of the vector's values</summary>
			</method>
</interface>
<interface name="BrightWire.IVolumeDataSource" base="">
	<summary>
		Volume (3D tensor) based data sources
	</summary>
		<property type="System.Int32" name="Width">
		<summary>Width of each input volume</summary>
	</property>
	<property type="System.Int32" name="Height">
		<summary>Height of each input volume</summary>
	</property>
	<property type="System.Int32" name="Depth">
		<summary>Depth of each input volume</summary>
	</property>
</interface>
<interface name="BrightWire.IWeightedIndexListEncoder" base="">
	<summary>
		Encodes weighted index lists to dense vectors
	</summary>
		<method type="System.Single[]" name="Encode">
		<summary>Encodes the weighted index list to a dense vector</summary>
				<param type="BrightWire.Models.WeightedIndexList" name="indexList" summary="" />
			</method>
</interface>
<interface name="BrightWire.IWeightInitialisation" base="">
	<summary>
		Neural network weight initialiser
	</summary>
		<method type="BrightWire.IVector" name="CreateBias">
		<summary>Creates the bias vector</summary>
				<param type="System.Int32" name="size" summary="The size of the vector" />
			</method>
	<method type="BrightWire.IMatrix" name="CreateWeight">
		<summary>Creates the weight matrix</summary>
				<param type="System.Int32" name="rows" summary="Row count" />
				<param type="System.Int32" name="columns" summary="Column count" />
			</method>
</interface>
<interface name="BrightWire.IWire" base="">
	<summary>
		Wires connect nodes in the graph
	</summary>
		<property type="BrightWire.INode" name="SendTo">
		<summary>The node to send a signal to</summary>
	</property>
	<property type="System.Int32" name="Channel">
		<summary>The channel</summary>
	</property>
</interface>

<class name="BrightWire.TrainingData.Artificial.And" base="" is-static="true" is-abstract="false">
	<summary>
		Simple AND training data
	</summary>
	<method type="BrightWire.IDataTable" name="Get" is-static="true">
		<summary>Generates a data table containing AND training data</summary>
			</method>
</class>
<class name="BrightWire.ExecutionGraph.Node.BackpropagationBase&lt;T&gt;" base="" is-static="false" is-abstract="true">
	<summary>
		Base class for node backpropagation
	</summary>
	<method type="System.Void" name="Dispose" is-static="false">
		<summary>Dispose</summary>
			</method>
	<method type="System.Void" name="Backward" is-static="false">
		<summary>Called when backpropagating</summary>
				<param type="BrightWire.INode" name="fromNode" summary="The node that sent the backpropagation signal" />
				<param type="BrightWire.IGraphData" name="errorSignal" summary="The backpropagating error" />
				<param type="BrightWire.IContext" name="context" summary="Graph context" />
				<param type="System.Collections.Generic.IReadOnlyList&lt;BrightWire.INode&gt;" name="parents" summary="Parents of the current node" />
			</method>
	<method type="System.Void" name="_Backward" is-static="false">
		<summary>Called when a valid error signal has been received</summary>
				<param type="BrightWire.INode" name="fromNode" summary=">The node that sent the backpropagation signal" />
				<param type="BrightWire.IGraphData" name="errorSignal" summary="The backpropagating error" />
				<param type="BrightWire.IContext" name="context" summary="Graph context" />
				<param type="System.Collections.Generic.IReadOnlyList&lt;BrightWire.INode&gt;" name="parents" summary="Parents of the current node" />
			</method>
</class>
<class name="BrightWire.Models.Bayesian.BernoulliNaiveBayes" base="" is-static="false" is-abstract="false">
	<summary>
		A bernoulli naive bayes model
	</summary>
	<property type="BrightWire.Models.Bayesian.BernoulliNaiveBayes.Class[]" name="ClassData">
		<summary>Classification data</summary>
	</property>
	<property type="System.UInt32[]" name="Vocabulary">
		<summary>The list of string indexes that were in the training set</summary>
	</property>
	<method type="BrightWire.IIndexListClassifier" name="CreateClassifier" is-static="false">
		<summary>Creates a classifier from this model</summary>
			</method>
</class>
<class name="BrightWire.TrainingData.Helper.BigEndianBinaryReader" base="System.IO.BinaryReader" is-static="false" is-abstract="false">
	<summary>
		Binary reader for big endian streams
	</summary>
	<method type="System.Void" name="BigEndianBinaryReader" is-static="false">
		<summary>Creates a new big endian binary reader</summary>
				<param type="System.IO.Stream" name="stream" summary="" />
			</method>
	<method type="System.Int32" name="ReadInt32" is-static="false">
		<summary>Reads an int</summary>
			</method>
	<method type="System.Int16" name="ReadInt16" is-static="false">
		<summary>Reads a short</summary>
			</method>
	<method type="System.Int64" name="ReadInt64" is-static="false">
		<summary>Reads a long</summary>
			</method>
	<method type="System.UInt32" name="ReadUInt32" is-static="false">
		<summary>Reads a ulong</summary>
			</method>
</class>
<class name="BrightWire.ExecutionGraph.Node.Gate.BinaryGateBase" base="BrightWire.ExecutionGraph.Node.NodeBase" is-static="false" is-abstract="true">
	<summary>
		Base class for nodes that accept two input signals and output one signal
	</summary>
	<method type="System.Void" name="BinaryGateBase" is-static="false">
		<summary>Constructor</summary>
				<param type="System.String" name="name" summary="" />
			</method>
	<method type="System.Void" name="ExecuteForward" is-static="false">
		<summary>Executes on the primary channel</summary>
				<param type="BrightWire.IContext" name="context" summary="The graph context" />
			</method>
</class>
<class name="BrightWire.TrainingData.Artificial.BinaryIntegers" base="" is-static="false" is-abstract="false">
	<summary>
		Creates random integers and returns feature vectors against binary mathematical logic
	</summary>
	<method type="BrightWire.IDataTable" name="Addition" is-static="true">
		<summary>Creates random integers added together as feature vectors
The input feature contains two features, one for each bit at that position
The output feature contains a single feature: 1 or 0 if that bit is set in the result</summary>
				<param type="System.Int32" name="sampleCount" summary="How many samples to generate" />
				<param type="System.Boolean" name="stochastic" summary="True to generate random integers" />
			</method>
</class>
<class name="BrightWire.LinearAlgebra.Helper.BoundMath" base="" is-static="false" is-abstract="false">
	<summary>
		Floating point helper that prevents values from getting too big or small
	</summary>
	<method type="System.Single" name="Constrain" is-static="true">
		<summary>Forces the value to lie within the valid range</summary>
				<param type="System.Single" name="val" summary="Value to check" />
			</method>
	<method type="System.Single" name="Exp" is-static="true">
		<summary>Bounded exponent</summary>
				<param type="System.Single" name="val" summary="" />
			</method>
	<method type="System.Single" name="Log" is-static="true">
		<summary>Bounded natural log</summary>
				<param type="System.Single" name="d" summary="" />
			</method>
	<method type="System.Single" name="Pow" is-static="true">
		<summary>Bounded power</summary>
				<param type="System.Single" name="x" summary="" />
				<param type="System.Single" name="y" summary="" />
			</method>
</class>
<class name="BrightWire.BrightWireGpuProvider" base="" is-static="true" is-abstract="false">
	<summary>
		Provides a GPU based linear algebra provider
	</summary>
	<method type="BrightWire.ILinearAlgebraProvider" name="CreateLinearAlgebra" is-static="true">
		<summary>Creates a linear alebra provider that runs on the GPU</summary>
				<param type="System.Boolean" name="stochastic" summary="False to disable random number generation" />
				<param type="System.Int32" name="memoryCacheSize" summary="The amount of device memory to use an application memory cache" />
				<param type="System.String" name="cudaKernelPath" summary="Path to .cubin or .ptx kernel file (defaults to .ptx file for forward compatability)" />
			</method>
	<method type="System.String" name="GetKernelPath" is-static="true">
		<summary>Returns the default cuda kernel path</summary>
			</method>
</class>
<class name="BrightWire.BrightWireProvider" base="" is-static="true" is-abstract="false">
	<summary>
		Main entry point
	</summary>
	<method type="BrightWire.IDataTable" name="ParseCSV" is-static="true">
		<summary>Parses a CSV file into a data table</summary>
				<param type="System.IO.StreamReader" name="streamReader" summary="The stream of CSV data" />
				<param type="System.Char" name="delimeter" summary="The CSV delimeter" />
				<param type="System.Nullable&lt;System.Boolean&gt;" name="hasHeader" summary="True if there is a header" />
				<param type="System.IO.Stream" name="output" summary="A stream to write the data table to (for file based processing) - null for in memory processing" />
			</method>
	<method type="BrightWire.IDataTable" name="ParseCSV" is-static="true">
		<summary>Parses a CSV string into a data table</summary>
				<param type="System.String" name="csv" summary="The string to parse" />
				<param type="System.Char" name="delimeter" summary="The CSV delimeter" />
				<param type="System.Nullable&lt;System.Boolean&gt;" name="hasHeader" summary="True if there is a header" />
				<param type="System.IO.Stream" name="output" summary="A stream to write the data table to (for file based processing) - null for in memory processing" />
			</method>
	<method type="BrightWire.IDataTable" name="ParseCSVToText" is-static="true">
		<summary>Parses CSV into a data table without type detection - all columns will be strings</summary>
				<param type="System.IO.StreamReader" name="streamReader" summary="The streamn reader that contains the CSV to parse" />
				<param type="System.Char" name="delimeter" summary="The CSV delimeter" />
				<param type="System.Nullable&lt;System.Boolean&gt;" name="hasHeader" summary="True if there is a header" />
				<param type="System.IO.Stream" name="output" summary="A stream to write the data table to (for file based processing) - null for in memory processing" />
			</method>
	<method type="BrightWire.IDataTable" name="ParseCSVToText" is-static="true">
		<summary>Parses CSV into a data table without type detection - all columns will be strings</summary>
				<param type="System.String" name="csv" summary="The string to parse" />
				<param type="System.Char" name="delimeter" summary=">The CSV delimeter" />
				<param type="System.Nullable&lt;System.Boolean&gt;" name="hasHeader" summary="True if there is a header" />
				<param type="System.IO.Stream" name="output" summary="A stream to write the data table to (for file based processing) - null for in memory processing" />
			</method>
	<method type="BrightWire.IDataTable" name="CreateDataTable" is-static="true">
		<summary>Creates a data table from a stream</summary>
				<param type="System.IO.Stream" name="dataStream" summary="The stream that the data table was written to" />
				<param type="System.IO.Stream" name="indexStream" summary="The stream that the index was written to (optional)" />
			</method>
	<method type="BrightWire.ILinearAlgebraProvider" name="CreateLinearAlgebra" is-static="true">
		<summary>Creates a linear algebra provider that runs on the CPU</summary>
				<param type="System.Boolean" name="stochastic" summary="False to use the same random number generation each time" />
			</method>
	<method type="BrightWire.IDataTableBuilder" name="CreateDataTableBuilder" is-static="true">
		<summary>Creates a data table builder to programatically create data tables</summary>
				<param type="System.IO.Stream" name="stream" summary="" />
			</method>
	<method type="BrightWire.IDataTableBuilder" name="CreateDataTableBuilder" is-static="true">
		<summary>Creates a data table builder to programatically create data tables</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;BrightWire.IColumn&gt;" name="columns" summary="" />
				<param type="System.IO.Stream" name="stream" summary="" />
			</method>
	<method type="BrightWire.IMarkovModelTrainer2&lt;T&gt;" name="CreateMarkovTrainer2" is-static="true">
		<summary>Create a markov model trainer of window size 2</summary>
				<param type="System.Int32" name="minObservations" summary="Minimum number of data points to record an observation" />
			</method>
	<method type="BrightWire.IMarkovModelTrainer3&lt;T&gt;" name="CreateMarkovTrainer3" is-static="true">
		<summary>Create a markov model trainer of window size 3</summary>
				<param type="System.Int32" name="minObservations" summary="Minimum number of data points to record an observation" />
			</method>
</class>
<class name="BrightWire.Models.Bayesian.NaiveBayes.CategorialColumn" base="" is-static="false" is-abstract="false">
	<summary>
		A categorical column model
	</summary>
	<property type="System.Int32" name="ColumnIndex">
		<summary>The column index</summary>
	</property>
	<property type="System.Collections.Generic.List&lt;BrightWire.Models.Bayesian.NaiveBayes.CategorialProbability&gt;" name="Probability">
		<summary>The list of categories within the column and their probability</summary>
	</property>
	<property type="BrightWire.Models.Bayesian.NaiveBayes.ColumnType" name="Type">
		<summary>The column type</summary>
	</property>
</class>
<class name="BrightWire.Models.Bayesian.NaiveBayes.CategorialProbability" base="" is-static="false" is-abstract="false">
	<summary>
		A category and its associated log probability
	</summary>
	<property type="System.String" name="Category">
		<summary>The category label</summary>
	</property>
	<property type="System.Double" name="LogProbability">
		<summary>The log of the category's probability</summary>
	</property>
</class>
<class name="BrightWire.Source.Models.DataTable.DataTableVectorisation.CategoricalIndex" base="" is-static="false" is-abstract="false">
	<summary>
		A categorical column value
	</summary>
	<property type="System.String" name="Category">
		<summary>The classification label</summary>
	</property>
	<property type="System.Int32" name="Index">
		<summary>The label's index</summary>
	</property>
</class>
<class name="BrightWire.Unsupervised.KMeans.ClusterData.Centroid" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<property type="BrightWire.IVector" name="Current">
		<summary></summary>
	</property>
	<property type="System.Collections.Generic.IReadOnlyList&lt;BrightWire.IVector&gt;" name="Data">
		<summary></summary>
	</property>
	<method type="System.Void" name="Centroid" is-static="false">
		<summary></summary>
				<param type="BrightWire.IVector" name="data" summary="" />
			</method>
	<method type="System.Void" name="Dispose" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Boolean" name="Update" is-static="false">
		<summary></summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;BrightWire.IVector&gt;" name="data" summary="" />
			</method>
</class>
<class name="BrightWire.Models.Bayesian.BernoulliNaiveBayes.Class" base="" is-static="false" is-abstract="false">
	<summary>
		A classification
	</summary>
	<property type="System.String" name="Label">
		<summary>The classification label</summary>
	</property>
	<property type="System.Double" name="Prior">
		<summary>The log of the prior probablilty for this classification</summary>
	</property>
	<property type="System.Double" name="MissingProbability">
		<summary>The log of the missing probability</summary>
	</property>
	<property type="BrightWire.Models.Bayesian.BernoulliNaiveBayes.StringIndexProbability[]" name="Index">
		<summary>The list of probabilities for each string index</summary>
	</property>
	<property type="System.Double" name="InverseMissingProbability">
		<summary>The log of the inverse missing probability</summary>
	</property>
</class>
<class name="BrightWire.Models.Bayesian.MultinomialNaiveBayes.Class" base="" is-static="false" is-abstract="false">
	<summary>
		Classification data
	</summary>
	<property type="System.String" name="Label">
		<summary>The classification label</summary>
	</property>
	<property type="System.Double" name="Prior">
		<summary>The classification's prior log probability</summary>
	</property>
	<property type="System.Double" name="MissingProbability">
		<summary>The classifications missing log probability</summary>
	</property>
	<property type="BrightWire.Models.Bayesian.MultinomialNaiveBayes.StringIndexProbability[]" name="Index">
		<summary>The list of string indexes and their probability</summary>
	</property>
</class>
<class name="BrightWire.Models.Bayesian.NaiveBayes.ClassSummary" base="" is-static="false" is-abstract="false">
	<summary>
		A classification and its associated data
	</summary>
	<property type="System.String" name="Label">
		<summary>The classification label</summary>
	</property>
	<property type="System.Double" name="Prior">
		<summary>The classification prior probability</summary>
	</property>
	<property type="System.Collections.Generic.List&lt;BrightWire.Models.Bayesian.NaiveBayes.IColumn&gt;" name="ColumnSummary">
		<summary>The column data associated with this classification</summary>
	</property>
</class>
<class name="BrightWire.Models.DataTable.DataTableNormalisation.Column" base="" is-static="false" is-abstract="false">
	<summary>
		A column model
	</summary>
	<property type="System.Int32" name="ColumnIndex">
		<summary>The column index</summary>
	</property>
	<property type="BrightWire.ColumnType" name="DataType">
		<summary>The type of data in the column</summary>
	</property>
	<property type="System.Double" name="Subtract">
		<summary>The value to subtract from the column</summary>
	</property>
	<property type="System.Double" name="Divide">
		<summary>The value to divide the column with (after subtraction)</summary>
	</property>
	<method type="System.Void" name="Column" is-static="false">
		<summary>Default constructor</summary>
			</method>
	<method type="System.Void" name="Column" is-static="false">
		<summary>Constructor</summary>
				<param type="System.Int32" name="columnIndex" summary="" />
				<param type="BrightWire.ColumnType" name="dataType" summary="" />
				<param type="System.Double" name="divide" summary="" />
				<param type="System.Double" name="subtract" summary="" />
			</method>
	<method type="System.Object" name="Normalise" is-static="false">
		<summary>Perform the normalisation step</summary>
				<param type="System.Double" name="val" summary="The input value" />
			</method>
</class>
<class name="BrightWire.Source.Models.DataTable.DataTableVectorisation.Column" base="" is-static="false" is-abstract="false">
	<summary>
		Column information
	</summary>
	<property type="System.Int32" name="ColumnIndex">
		<summary>The column index</summary>
	</property>
	<property type="System.String" name="Name">
		<summary>Column name</summary>
	</property>
	<property type="System.Boolean" name="IsTargetColumn">
		<summary>True if the column is the classification target</summary>
	</property>
	<property type="System.Boolean" name="IsContinuous">
		<summary>True if the column has a continuous value</summary>
	</property>
	<property type="System.Int32" name="Size">
		<summary>The number slots this column will fill in the output vector</summary>
	</property>
	<property type="BrightWire.Source.Models.DataTable.DataTableVectorisation.CategoricalIndex[]" name="Values">
		<summary>An array of categorial values</summary>
	</property>
</class>
<class name="BrightWire.TreeBased.Training.DecisionTreeTrainer.Config" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<property type="System.Nullable&lt;System.Int32&gt;" name="FeatureBagCount">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.Int32&gt;" name="MinDataPerNode">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.Int32&gt;" name="MaxDepth">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.Double&gt;" name="MinInformationGain">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.Int32&gt;" name="MaxAttributes">
		<summary></summary>
	</property>
</class>
<class name="BrightWire.Models.Bayesian.NaiveBayes.ContinuousGaussianColumn" base="" is-static="false" is-abstract="false">
	<summary>
		A continous column model
	</summary>
	<property type="System.Int32" name="ColumnIndex">
		<summary>The column index</summary>
	</property>
	<property type="System.Double" name="Variance">
		<summary>The variance of the column values</summary>
	</property>
	<property type="System.Double" name="Mean">
		<summary>The mean of the column values</summary>
	</property>
	<property type="BrightWire.Models.Bayesian.NaiveBayes.ColumnType" name="Type">
		<summary>The column type</summary>
	</property>
</class>
<class name="BrightWire.Models.DataSourceModel" base="" is-static="false" is-abstract="false">
	<summary>
		Serialises an adaptive data source - that is, a data source that takes the output from a preliminary output graph and sends it to the primary graph
	</summary>
	<property type="System.String" name="Version">
		<summary>Data contract version number</summary>
	</property>
	<property type="System.String" name="Name">
		<summary>The name of the data source</summary>
	</property>
	<property type="System.Int32" name="InputSize">
		<summary>The size of each input training data item</summary>
	</property>
	<property type="System.Int32" name="OutputSize">
		<summary>The size of each training item output (classification label)</summary>
	</property>
	<property type="BrightWire.Models.ExecutionGraph" name="Graph">
		<summary>The preliminary graph</summary>
	</property>
</class>
<class name="BrightWire.Models.DataTable.DataTableNormalisation" base="" is-static="false" is-abstract="false">
	<summary>
		A data table normalisation model
	</summary>
	<property type="BrightWire.NormalisationType" name="Type">
		<summary>The type of normalisation</summary>
	</property>
	<property type="BrightWire.Models.DataTable.DataTableNormalisation.Column[]" name="ColumnNormalisation">
		<summary>The column normalisation data</summary>
	</property>
	<method type="System.Collections.Generic.IReadOnlyList&lt;System.Object&gt;" name="Normalise" is-static="false">
		<summary>Normalises a row in the data table</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;System.Object&gt;" name="row" summary="The row to normalise" />
			</method>
</class>
<class name="BrightWire.Source.Models.DataTable.DataTableVectorisation" base="" is-static="false" is-abstract="false">
	<summary>
		A data table vectorisation model - maps rows in a data table to vectors
	</summary>
	<property type="BrightWire.Source.Models.DataTable.DataTableVectorisation.Column[]" name="Columns">
		<summary>The columns in the table</summary>
	</property>
	<property type="System.Int32" name="InputSize">
		<summary>The size of each input vector that will be created</summary>
	</property>
	<property type="System.Int32" name="OutputSize">
		<summary>The size of each output vector that will be created</summary>
	</property>
	<property type="System.Boolean" name="HasTarget">
		<summary>True if the vectoriser has a classification target column</summary>
	</property>
	<property type="System.Boolean" name="IsTargetContinuous">
		<summary>True if the classification target column is continuous</summary>
	</property>
	<property type="System.Int32" name="ClassColumnIndex">
		<summary>The column index of the classifiation target column</summary>
	</property>
	<property type="System.Collections.Generic.Dictionary&lt;System.Int32, System.Collections.Generic.Dictionary&lt;System.String, System.Int32&gt;&gt;" name="ColumnMap">
		<summary>A dictionary of column to categorical value tables</summary>
	</property>
	<property type="System.Collections.Generic.Dictionary&lt;System.Int32, System.Collections.Generic.Dictionary&lt;System.Int32, System.String&gt;&gt;" name="ReverseColumnMap">
		<summary>A dictionary of column to reversed categorical value tables</summary>
	</property>
	<method type="System.String" name="GetOutputLabel" is-static="false">
		<summary>Returns the classification label for the corresponding column/vector indices</summary>
				<param type="System.Int32" name="columnIndex" summary="The data table column index" />
				<param type="System.Int32" name="vectorIndex" summary="The one hot vector index" />
			</method>
	<method type="BrightWire.Models.FloatVector" name="GetInput" is-static="false">
		<summary>Vectorises the input columns of the specified row</summary>
				<param type="BrightWire.IRow" name="row" summary=">The row to vectorise" />
			</method>
	<method type="BrightWire.Models.FloatVector" name="GetOutput" is-static="false">
		<summary>Vectorises the output column of the specified row</summary>
				<param type="BrightWire.IRow" name="row" summary="The row to vectorise" />
			</method>
</class>
<class name="BrightWire.Models.DecisionTree" base="" is-static="false" is-abstract="false">
	<summary>
		A decision tree model
	</summary>
	<property type="System.Int32" name="ClassColumnIndex">
		<summary>The classification label column index</summary>
	</property>
	<property type="BrightWire.Models.DecisionTree.Node" name="Root">
		<summary>The root of the tree</summary>
	</property>
	<property type="System.String" name="AsXml">
		<summary>Converts the tree to XML</summary>
	</property>
	<method type="BrightWire.IRowClassifier" name="CreateClassifier" is-static="false">
		<summary>Creates a classifier from the model</summary>
			</method>
</class>
<class name="BrightWire.ExecutionGraph.GraphFactory.ErrorMetricProvider" base="" is-static="false" is-abstract="false">
	<summary>
		Error metrics
	</summary>
	<property type="BrightWire.IErrorMetric" name="BinaryClassification">
		<summary>Binary classification error metric</summary>
	</property>
	<property type="BrightWire.IErrorMetric" name="CrossEntropy">
		<summary>Cross entropy error metric</summary>
	</property>
	<property type="BrightWire.IErrorMetric" name="OneHotEncoding">
		<summary>One hot encoding error metric</summary>
	</property>
	<property type="BrightWire.IErrorMetric" name="Quadratic">
		<summary>Quadratic error metric</summary>
	</property>
</class>
<class name="BrightWire.Models.ExecutionGraph" base="" is-static="false" is-abstract="false">
	<summary>
		A serialised execution graph
	</summary>
	<property type="System.String" name="Version">
		<summary>Data contract version number</summary>
	</property>
	<property type="System.String" name="Name">
		<summary>The name of the graph</summary>
	</property>
	<property type="BrightWire.Models.ExecutionGraph.Node" name="InputNode">
		<summary>The primary input node</summary>
	</property>
	<property type="BrightWire.Models.ExecutionGraph.Node[]" name="OtherNodes">
		<summary>Other connected nodes</summary>
	</property>
	<property type="BrightWire.Models.ExecutionGraph.Wire[]" name="Wires">
		<summary>A list of the wires that connect the nodes in the graph</summary>
	</property>
</class>
<class name="BrightWire.Models.ExecutionResult" base="" is-static="false" is-abstract="false">
	<summary>
		The output from a mini batch
	</summary>
	<method type="System.Void" name="ExecutionResult" is-static="false">
		<summary>Constructor</summary>
				<param type="BrightWire.IMiniBatchSequence" name="miniBatch" summary="The mini batch sequence" />
				<param type="System.Collections.Generic.IReadOnlyList&lt;BrightWire.Models.FloatVector&gt;" name="output" summary="The mini batch output" />
			</method>
	<property type="System.Collections.Generic.IReadOnlyList&lt;BrightWire.Models.FloatVector&gt;" name="Output">
		<summary>The list of output rows</summary>
	</property>
	<property type="System.Collections.Generic.IReadOnlyList&lt;BrightWire.Models.FloatVector&gt;" name="Target">
		<summary>The list of target rows</summary>
	</property>
	<property type="System.Collections.Generic.IReadOnlyList&lt;System.Collections.Generic.IReadOnlyList&lt;BrightWire.Models.FloatVector&gt;&gt;" name="Input">
		<summary>The list of input rows</summary>
	</property>
	<property type="BrightWire.IMiniBatchSequence" name="MiniBatchSequence">
		<summary>The mini batch</summary>
	</property>
	<method type="System.Single" name="CalculateError" is-static="false">
		<summary>Calculates the error of the output against the target</summary>
				<param type="BrightWire.IErrorMetric" name="errorMetric" summary="The error metric to calculate with" />
			</method>
</class>
<class name="BrightWire.ExtensionMethods" base="" is-static="true" is-abstract="false">
	<summary>
		Static extension methods
	</summary>
	<method type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="Shuffle" is-static="true">
		<summary>Shuffles the enumerable</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="seq" summary="The sequence to shuffle" />
				<param type="System.Nullable&lt;System.Int32&gt;" name="randomSeed" summary="The random seed to use or null for a random shuffle" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="Shuffle" is-static="true">
		<summary>Shuffles the enumerable</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="seq" summary="The sequence to shuffle" />
				<param type="System.Random" name="rnd" summary="The random number generator to use" />
			</method>
	<method type="(System.Collections.Generic.IReadOnlyList&lt;T&gt; Training, System.Collections.Generic.IReadOnlyList&lt;T&gt; Test)" name="Split" is-static="true">
		<summary>Splits a sequence into training and test splits</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;T&gt;" name="seq" summary="The sequence to split" />
				<param type="System.Double" name="trainPercentage" summary="The percentage of the sequence to add to the training set" />
			</method>
	<method type="System.Collections.Generic.IReadOnlyList&lt;T&gt;" name="Bag" is-static="true">
		<summary>Bags (select with replacement) the input sequence</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;T&gt;" name="list" summary="The input sequence" />
				<param type="System.Int32" name="count" summary="The size of the output sequence" />
				<param type="System.Nullable&lt;System.Int32&gt;" name="randomSeed" summary="The random seed or null initialise randomlu" />
			</method>
</class>
<class name="BrightWire.ExtensionMethods" base="" is-static="true" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Type" name="GetColumnType" is-static="true">
		<summary>Returns the underlying .net type associated with the column type</summary>
				<param type="BrightWire.ColumnType" name="type" summary="The column type" />
			</method>
	<method type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, BrightWire.Models.WeightedIndexList Data)&gt;" name="ConvertToWeightedIndexList" is-static="true">
		<summary>Converts the indexed classifications to weighted indexed classifications</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, BrightWire.Models.IndexList Data)&gt;" name="data" summary="" />
				<param type="System.Boolean" name="groupByClassification" summary="True to group by classification (i.e convert the bag to a set)" />
			</method>
	<method type="BrightWire.IDataTable" name="ConvertToTable" is-static="true">
		<summary>Converts indexed classifications to a data table</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, BrightWire.Models.IndexList Data)&gt;" name="data" summary="" />
			</method>
	<method type="BrightWire.IDataTable" name="ConvertToTable" is-static="true">
		<summary>Converts weighted index classifications to a data table</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, BrightWire.Models.WeightedIndexList Data)&gt;" name="data" summary="" />
			</method>
	<method type="BrightWire.IDataTable" name="ConvertToTable" is-static="true">
		<summary>Converts the vector classifications into a data table</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, BrightWire.Models.FloatVector Data)&gt;" name="data" summary="" />
				<param type="System.Boolean" name="preserveVectors" summary="True to create a data table with a vector column type, false to to convert to columns of floats" />
			</method>
	<method type="System.Single" name="GetMaxWeight" is-static="true">
		<summary>Finds the greatest weight within the weighted index classification list</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, BrightWire.Models.WeightedIndexList Data)&gt;" name="data" summary="" />
			</method>
	<method type="System.UInt32" name="GetMaxIndex" is-static="true">
		<summary>Find the greatest index within the weighted index classification list</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, BrightWire.Models.WeightedIndexList Data)&gt;" name="data" summary="" />
			</method>
	<method type="System.UInt32" name="GetMaxIndex" is-static="true">
		<summary>Find the greatest index within the index classification list</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, BrightWire.Models.IndexList Data)&gt;" name="data" summary="" />
			</method>
	<method type="System.Collections.Generic.IReadOnlyList&lt;(System.String Classification, BrightWire.Models.FloatVector Data)&gt;" name="Vectorise" is-static="true">
		<summary>Converts the weighted index classification list to a list of dense vectors</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, BrightWire.Models.WeightedIndexList Data)&gt;" name="data" summary="" />
			</method>
	<method type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, System.String Classification, System.Single Score)&gt;" name="Classify" is-static="true">
		<summary>Classifies each row of the index classification list</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, BrightWire.Models.IndexList Data)&gt;" name="data" summary="" />
				<param type="BrightWire.IIndexListClassifier" name="classifier" summary="The classifier to classify each item in the list" />
			</method>
	<method type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, BrightWire.Models.WeightedIndexList Data)&gt;" name="Normalise" is-static="true">
		<summary>Normalises the weighted index classification list to fit between 0 and 1</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, BrightWire.Models.WeightedIndexList Data)&gt;" name="data" summary="" />
			</method>
	<method type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, BrightWire.Models.WeightedIndexList Data)&gt;" name="TFIDF" is-static="true">
		<summary>Modifies the weights in the classification set based on relative corpus statistics to increase the weight of important words relative to each document
https://en.wikipedia.org/wiki/Tf%E2%80%93idf</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, BrightWire.Models.WeightedIndexList Data)&gt;" name="data" summary="" />
			</method>
</class>
<class name="BrightWire.ExtensionMethods" base="" is-static="true" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="Train" is-static="true">
		<summary>Trains a graph for a fixed number of iterations</summary>
				<param type="BrightWire.IGraphTrainingEngine" name="engine" summary="The graph training engine" />
				<param type="System.Int32" name="numIterations" summary="The number of iterations to train for" />
				<param type="BrightWire.IDataSource" name="testData" summary="The test data source to use" />
				<param type="BrightWire.IErrorMetric" name="errorMetric" summary="The error metric to evaluate the test data against" />
				<param type="System.Action&lt;BrightWire.Models.GraphModel&gt;" name="onImprovement" summary="Optional callback for when the test data score has improved against the error metric" />
				<param type="System.Int32" name="testCadence" summary="Determines how many epochs elapse before the test data is evaluated" />
			</method>
	<method type="System.Collections.Generic.IReadOnlyList&lt;(BrightWire.IRow Row, System.String Classification)&gt;" name="Classifiy" is-static="true">
		<summary>Classifies each row of the data table</summary>
				<param type="BrightWire.IRowClassifier" name="classifier" summary="" />
				<param type="BrightWire.IDataTable" name="dataTable" summary="" />
			</method>
	<method type="BrightWire.Models.ExecutionGraph" name="GetGraph" is-static="true">
		<summary>Serialises the node and any other connected nodes to an execution graph</summary>
				<param type="BrightWire.INode" name="input" summary="" />
				<param type="System.String" name="name" summary="Name of the graph (optional)" />
			</method>
	<method type="BrightWire.INode" name="CreateFrom" is-static="true">
		<summary>Creates a node and any other connected nodes from a serialised execution graph</summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="factory" summary="" />
				<param type="BrightWire.Models.ExecutionGraph" name="graph" summary="Serialised graph" />
			</method>
</class>
<class name="BrightWire.ExtensionMethods" base="" is-static="true" is-abstract="false">
	<summary>
		
	</summary>
	<method type="BrightWire.IVector" name="CreateVector" is-static="true">
		<summary>Create a vector</summary>
				<param type="BrightWire.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="BrightWire.IIndexableVector" name="data" summary="Indexable vector to copy" />
			</method>
	<method type="BrightWire.IVector" name="CreateVector" is-static="true">
		<summary>Create a vector</summary>
				<param type="BrightWire.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="BrightWire.Models.FloatVector" name="data" summary="Vector to copy" />
			</method>
	<method type="BrightWire.IVector" name="CreateVector" is-static="true">
		<summary>Create a vector</summary>
				<param type="BrightWire.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="System.Collections.Generic.IReadOnlyList&lt;System.Single&gt;" name="data" summary="List of values" />
			</method>
	<method type="BrightWire.IVector" name="CreateVector" is-static="true">
		<summary>Create a vector</summary>
				<param type="BrightWire.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="System.Int32" name="length" summary="Vector size" />
				<param type="System.Single" name="value" summary="Constant value" />
			</method>
	<method type="BrightWire.IMatrix" name="CreateMatrix" is-static="true">
		<summary>Create a matrix</summary>
				<param type="BrightWire.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="BrightWire.Models.FloatMatrix" name="matrix" summary="Matrix to copy" />
			</method>
	<method type="BrightWire.IMatrix" name="CreateMatrix" is-static="true">
		<summary>Create a matrix</summary>
				<param type="BrightWire.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="System.Collections.Generic.IReadOnlyList&lt;BrightWire.Models.FloatVector&gt;" name="rowList" summary="List of vectors (each vector becomes a row in the new matrix)" />
			</method>
	<method type="BrightWire.IMatrix" name="CreateMatrix" is-static="true">
		<summary>Create a matrix</summary>
				<param type="BrightWire.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="System.Collections.Generic.IReadOnlyList&lt;BrightWire.IIndexableVector&gt;" name="rowList" summary="List of indexable vectors (each vector becomes a row in the new matrix)" />
			</method>
	<method type="BrightWire.IMatrix" name="CreateMatrix" is-static="true">
		<summary>Create a matrix</summary>
				<param type="BrightWire.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="System.Int32" name="rows" summary="Matrix rows" />
				<param type="System.Int32" name="columns" summary="Matrix columns" />
				<param type="System.Single" name="value" summary="Constant value" />
			</method>
	<method type="BrightWire.IMatrix" name="CreateMatrix" is-static="true">
		<summary>Create a matrix</summary>
				<param type="BrightWire.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="BrightWire.IIndexableMatrix" name="matrix" summary="Indexable matrix to copy" />
			</method>
	<method type="BrightWire.IMatrix" name="CreateIdentityMatrix" is-static="true">
		<summary>Create an identity matrix</summary>
				<param type="BrightWire.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="System.Int32" name="size" summary="Width and height of the new matrix" />
			</method>
	<method type="BrightWire.IMatrix" name="CreateDiagonalMatrix" is-static="true">
		<summary>Create a diagonal matrix</summary>
				<param type="BrightWire.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="System.Collections.Generic.IReadOnlyList&lt;System.Single&gt;" name="values" summary="List of diagonal values" />
			</method>
	<method type="BrightWire.I3DTensor" name="Create3DTensor" is-static="true">
		<summary>Create a 3D tensor</summary>
				<param type="BrightWire.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="BrightWire.IIndexable3DTensor" name="tensor" summary="An indexable 3D tensor to use as a source" />
			</method>
	<method type="BrightWire.I3DTensor" name="Create3DTensor" is-static="true">
		<summary>Create a 3D tensor</summary>
				<param type="BrightWire.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="BrightWire.Models.FloatTensor" name="tensor" summary="The serialised representation of the 3D tensor" />
			</method>
	<method type="BrightWire.IVector" name="Calculate" is-static="true">
		<summary>Calculates the distance between two matrices</summary>
				<param type="BrightWire.DistanceMetric" name="distance" summary="" />
				<param type="BrightWire.IMatrix" name="matrix1" summary="" />
				<param type="BrightWire.IMatrix" name="matrix2" summary="" />
			</method>
	<method type="System.Single" name="Calculate" is-static="true">
		<summary>Calculates the distance between two vectors</summary>
				<param type="BrightWire.DistanceMetric" name="distance" summary="" />
				<param type="BrightWire.IVector" name="vector1" summary="" />
				<param type="BrightWire.IVector" name="vector2" summary="" />
			</method>
</class>
<class name="BrightWire.ExtensionMethods" base="" is-static="true" is-abstract="false">
	<summary>
		
	</summary>
	<method type="BrightWire.IRandomProjection" name="CreateRandomProjection" is-static="true">
		<summary>Random projections allow you to reduce the dimensions of a matrix while still preserving significant information</summary>
				<param type="BrightWire.ILinearAlgebraProvider" name="lap" summary="Linear algebra provider" />
				<param type="System.Int32" name="fixedSize" summary="The vector size to reduce from" />
				<param type="System.Int32" name="reducedSize" summary="The vector size to reduce to" />
				<param type="System.Int32" name="s" summary="" />
			</method>
	<method type="BrightWire.Models.LogisticRegression" name="TrainLogisticRegression" is-static="true">
		<summary>Trains a logistic regression model on a data table</summary>
				<param type="BrightWire.IDataTable" name="table" summary="The training data" />
				<param type="BrightWire.ILinearAlgebraProvider" name="lap" summary="Linear algebra provider" />
				<param type="System.Int32" name="iterations" summary="Number of iterations to train for" />
				<param type="System.Single" name="learningRate" summary="The learning rate" />
				<param type="System.Single" name="lambda" summary="Regularisation lambda" />
			</method>
	<method type="BrightWire.ILogisticRegressionTrainer" name="CreateLogisticRegressionTrainer" is-static="true">
		<summary>Logistic regression learns a sigmoid function over a set of data that learns to classify future values into positive or negative samples</summary>
				<param type="BrightWire.IDataTable" name="table" summary="The training data provider" />
				<param type="BrightWire.ILinearAlgebraProvider" name="lap" summary="Linear algebra provider" />
			</method>
	<method type="System.Collections.Generic.List&lt;BrightWire.Models.Bayesian.MarkovModelStateTransition&lt;T&gt;&gt;" name="GetTransitions" is-static="true">
		<summary>Find the next set of state transitions from a pair of observations</summary>
				<param type="System.Collections.Generic.Dictionary&lt;BrightWire.Models.Bayesian.MarkovModelObservation2&lt;T&gt;, System.Collections.Generic.List&lt;BrightWire.Models.Bayesian.MarkovModelStateTransition&lt;T&gt;&gt;&gt;" name="model" summary="A markov model saved to a dictionary" />
				<param type="T" name="item1" summary="The first observation" />
				<param type="T" name="item2" summary="The second observation" />
			</method>
	<method type="System.Collections.Generic.List&lt;BrightWire.Models.Bayesian.MarkovModelStateTransition&lt;T&gt;&gt;" name="GetTransitions" is-static="true">
		<summary>Find the next set of state transitions from a tuple of observations</summary>
				<param type="System.Collections.Generic.Dictionary&lt;BrightWire.Models.Bayesian.MarkovModelObservation3&lt;T&gt;, System.Collections.Generic.List&lt;BrightWire.Models.Bayesian.MarkovModelStateTransition&lt;T&gt;&gt;&gt;" name="model" summary="A markov model saved to a dictionary" />
				<param type="T" name="item1" summary="The first observation" />
				<param type="T" name="item2" summary="The second observation" />
				<param type="T" name="item3" summary="The third observation" />
			</method>
	<method type="System.Collections.Generic.IReadOnlyList&lt;System.Collections.Generic.IReadOnlyList&lt;BrightWire.IVector&gt;&gt;" name="NNMF" is-static="true">
		<summary>Non negative matrix factorisation - clustering based on matrix factorisation. Only applicable for training data that is non-negative.</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;BrightWire.IVector&gt;" name="data" summary="The training data" />
				<param type="BrightWire.ILinearAlgebraProvider" name="lap" summary="Linear alegbra provider" />
				<param type="System.Int32" name="k" summary="The number of clusters" />
				<param type="System.Int32" name="maxIterations" summary="The maximum number of iterations" />
			</method>
	<method type="System.Collections.Generic.IReadOnlyList&lt;System.Collections.Generic.IReadOnlyList&lt;BrightWire.IVector&gt;&gt;" name="HierachicalCluster" is-static="true">
		<summary>Hierachical clustering successively finds the closest distance between pairs of centroids until k is reached</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;BrightWire.IVector&gt;" name="data" summary="The list of vectors to cluster" />
				<param type="System.Int32" name="k" summary="The number of clusters to find" />
			</method>
	<method type="System.Collections.Generic.IReadOnlyList&lt;System.Collections.Generic.IReadOnlyList&lt;BrightWire.IVector&gt;&gt;" name="KMeans" is-static="true">
		<summary>K Means uses coordinate descent and the euclidean distance between randomly selected centroids to cluster the data</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;BrightWire.IVector&gt;" name="data" summary="The list of vectors to cluster" />
				<param type="System.Int32" name="k" summary="The number of clusters to find" />
				<param type="System.Int32" name="maxIterations" summary="The maximum number of iterations" />
			</method>
	<method type="BrightWire.Models.InstanceBased.KNearestNeighbours" name="TrainKNearestNeighbours" is-static="true">
		<summary>K Nearest Neighbours is an instance based classification method that uses examples from training data to predict classifications</summary>
				<param type="BrightWire.IDataTable" name="data" summary="The training data" />
			</method>
	<method type="BrightWire.Models.MultinomialLogisticRegression" name="TrainMultinomialLogisticRegression" is-static="true">
		<summary>Multinomial Logistic Regression generalises Logistic Regression to multi-class classification</summary>
				<param type="BrightWire.IDataTable" name="data" summary="The training data" />
				<param type="BrightWire.ILinearAlgebraProvider" name="lap" summary="Linear algebra provider" />
				<param type="System.Int32" name="trainingIterations" summary="Number of training iterations" />
				<param type="System.Single" name="trainingRate" summary="Training rate" />
				<param type="System.Single" name="lambda" summary="L2 regularisation" />
			</method>
	<method type="BrightWire.Models.RandomForest" name="TrainRandomForest" is-static="true">
		<summary>Random forests are built on a bagged collection of features to try to capture the most salient points of the training data without overfitting</summary>
				<param type="BrightWire.IDataTable" name="data" summary="The training data" />
				<param type="System.Int32" name="b" summary="The number of trees in the forest" />
			</method>
	<method type="BrightWire.Models.DecisionTree" name="TrainDecisionTree" is-static="true">
		<summary>Decision trees build a logical tree to classify data. Various measures can be specified to prevent overfitting.</summary>
				<param type="BrightWire.IDataTable" name="data" summary="The training data" />
				<param type="System.Nullable&lt;System.Int32&gt;" name="minDataPerNode" summary="Minimum number of data points per node to continue splitting" />
				<param type="System.Nullable&lt;System.Int32&gt;" name="maxDepth" summary="The maximum depth of each leaf" />
				<param type="System.Nullable&lt;System.Double&gt;" name="minInformationGain" summary="The minimum information gain to continue splitting" />
				<param type="System.Nullable&lt;System.Int32&gt;" name="maxAttributes" summary="The maximum number of attributes to consider at each split" />
			</method>
	<method type="BrightWire.Models.Bayesian.MultinomialNaiveBayes" name="TrainMultinomialNaiveBayes" is-static="true">
		<summary>Multinomial naive bayes preserves the count of each feature within the model. Useful for long documents.</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;(System.String Classification, BrightWire.Models.IndexList Data)&gt;" name="data" summary="The training data table" />
			</method>
	<method type="BrightWire.Models.Bayesian.BernoulliNaiveBayes" name="TrainBernoulliNaiveBayes" is-static="true">
		<summary>Bernoulli naive bayes treats each feature as either 1 or 0 - all feature counts are discarded. Useful for short documents.</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;(System.String Classification, BrightWire.Models.IndexList Data)&gt;" name="data" summary="The training data table" />
			</method>
	<method type="BrightWire.Models.Bayesian.NaiveBayes" name="TrainNaiveBayes" is-static="true">
		<summary>Naive bayes is a classifier that assumes conditional independence between all features</summary>
				<param type="BrightWire.IDataTable" name="table" summary="The training data provider" />
			</method>
	<method type="BrightWire.ILinearRegressionTrainer" name="CreateLinearRegressionTrainer" is-static="true">
		<summary>Linear regression fits a line to a set of data that allows you predict future values</summary>
				<param type="BrightWire.IDataTable" name="table" summary="The training data table" />
				<param type="BrightWire.ILinearAlgebraProvider" name="lap" summary="Linear algebra provider" />
			</method>
	<method type="System.String" name="GetBestClassification" is-static="true">
		<summary>Finds the classification with the highest weight</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, System.Single Weight)&gt;" name="classifications" summary="List of weighted classifications" />
			</method>
</class>
<class name="BrightWire.Models.FloatMatrix" base="" is-static="false" is-abstract="false">
	<summary>
		A protobuf serialised matrix
	</summary>
	<property type="BrightWire.Models.FloatVector[]" name="Row">
		<summary>The rows of the matrix</summary>
	</property>
	<method type="BrightWire.Models.FloatMatrix" name="Create" is-static="true">
		<summary>Create a new float matrix with the specified rows</summary>
				<param type="BrightWire.Models.FloatVector[]" name="rows" summary="The rows in the matrix (each vector should be the same length)" />
			</method>
	<method type="BrightWire.Models.FloatMatrix" name="Create" is-static="true">
		<summary>Create a new float matrix with the specified number of rows and columns initialised to zero</summary>
				<param type="System.Int32" name="rowCount" summary="Number of rows" />
				<param type="System.Int32" name="columnCount" summary="Number of columns" />
			</method>
	<property type="System.Int32" name="RowCount">
		<summary>The number of rows</summary>
	</property>
	<property type="System.Int32" name="ColumnCount">
		<summary>The number of columns</summary>
	</property>
	<method type="System.String" name="ToString" is-static="false">
		<summary>ToString override</summary>
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary>Writes the data to an XML writer</summary>
				<param type="System.String" name="name" summary="The name to give the data" />
				<param type="System.Xml.XmlWriter" name="writer" summary="The writer to write to" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary>Writes the data to a binary writer</summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="BrightWire.Models.FloatMatrix" name="ReadFrom" is-static="true">
		<summary>Creates a float matrix from a binary reader</summary>
				<param type="System.IO.BinaryReader" name="reader" summary="The binary reader" />
			</method>
	<property type="System.String" name="Xml">
		<summary>Converts the matrix to XML</summary>
	</property>
	<method type="System.Boolean" name="IsEqualTo" is-static="false">
		<summary>Tests if the matrices are the same</summary>
				<param type="BrightWire.Models.FloatMatrix" name="matrix" summary="The matrix to compare" />
				<param type="System.Collections.Generic.IEqualityComparer&lt;System.Single&gt;" name="comparer" summary="Optional IEqualityComparer to use" />
			</method>
</class>
<class name="BrightWire.Models.FloatTensor" base="" is-static="false" is-abstract="false">
	<summary>
		A protobuf serialised 3D tensor
	</summary>
	<property type="BrightWire.Models.FloatMatrix[]" name="Matrix">
		<summary>The list of matrices that form the tensor</summary>
	</property>
	<method type="BrightWire.Models.FloatTensor" name="Create" is-static="true">
		<summary>Create a new 3D tensor</summary>
				<param type="BrightWire.Models.FloatMatrix[]" name="matrices" summary="List of matrices that form the 3D tensor (each should have the same dimensions)" />
			</method>
	<method type="BrightWire.Models.FloatTensor" name="Create" is-static="true">
		<summary>Create a new 3D tensor initialised to zero</summary>
				<param type="System.Int32" name="rowCount" summary="Row count of each matrix" />
				<param type="System.Int32" name="columnCount" summary="Column count of each matrix" />
				<param type="System.Int32" name="depth" summary="Depth of the 3D tensor (number of matrices)" />
			</method>
	<property type="System.Int32" name="RowCount">
		<summary>The number of rows</summary>
	</property>
	<property type="System.Int32" name="ColumnCount">
		<summary>The number of columns</summary>
	</property>
	<property type="System.Int32" name="Depth">
		<summary>The depth of the tensor</summary>
	</property>
	<method type="System.String" name="ToString" is-static="false">
		<summary>ToString override</summary>
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary>Writes the data to an XML writer</summary>
				<param type="System.String" name="name" summary="The name to give the data" />
				<param type="System.Xml.XmlWriter" name="writer" summary="The writer to write to" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary>Writes the data to a binary writer</summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="BrightWire.Models.FloatTensor" name="ReadFrom" is-static="true">
		<summary>Creates a float tensor from a binary reader</summary>
				<param type="System.IO.BinaryReader" name="reader" summary="The binary reader" />
			</method>
	<property type="System.String" name="Xml">
		<summary>Converts the tensor to XML</summary>
	</property>
	<property type="System.Int32" name="Size">
		<summary>Number of items in the tensor (depth * rows * columns)</summary>
	</property>
	<method type="System.Single[]" name="GetAsRaw" is-static="false">
		<summary>Converts the data to a column major vector</summary>
			</method>
	<method type="System.Boolean" name="IsEqualTo" is-static="false">
		<summary>Tests if the tensors are the same</summary>
				<param type="BrightWire.Models.FloatTensor" name="tensor" summary="The tensor to compare" />
				<param type="System.Collections.Generic.IEqualityComparer&lt;System.Single&gt;" name="comparer" summary="Optional IEqualityComparer to use" />
			</method>
</class>
<class name="BrightWire.Models.FloatVector" base="" is-static="false" is-abstract="false">
	<summary>
		An protobuf serialised vector
	</summary>
	<property type="System.Single[]" name="Data">
		<summary>The data</summary>
	</property>
	<method type="BrightWire.Models.FloatVector" name="Create" is-static="true">
		<summary>Create a new float vector with the specified data</summary>
				<param type="System.Single[]" name="data" summary="" />
			</method>
	<method type="BrightWire.Models.FloatVector" name="Create" is-static="true">
		<summary>Create a new float vector with each entry set to zero</summary>
				<param type="System.Int32" name="size" summary="Size of the vector" />
			</method>
	<property type="System.Int32" name="Size">
		<summary>The size of the vector</summary>
	</property>
	<method type="System.String" name="ToString" is-static="false">
		<summary>ToString override</summary>
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary>Writes the data to an XML writer</summary>
				<param type="System.String" name="name" summary="The name to give the data" />
				<param type="System.Xml.XmlWriter" name="writer" summary="The writer to write to" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary>Writes the data to a binary writer</summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="BrightWire.Models.FloatVector" name="ReadFrom" is-static="true">
		<summary>Creates a float array from a binary reader</summary>
				<param type="System.IO.BinaryReader" name="reader" summary="The binary reader" />
			</method>
	<property type="System.String" name="Xml">
		<summary>Converts the vector to XML</summary>
	</property>
	<method type="System.Boolean" name="IsEqualTo" is-static="false">
		<summary>Tests if the vectors are the same</summary>
				<param type="BrightWire.Models.FloatVector" name="vector" summary="The vector to compare" />
				<param type="System.Collections.Generic.IEqualityComparer&lt;System.Single&gt;" name="comparer" summary="Optional IEqualityComparer to use" />
			</method>
	<method type="System.Int32" name="MaximumIndex" is-static="false">
		<summary>Finds the index with the highest value</summary>
			</method>
</class>
<class name="BrightWire.ExecutionGraph.GraphFactory.GradientDescentProvider" base="" is-static="false" is-abstract="false">
	<summary>
		Prebuilt gradient descent optimisers
	</summary>
	<property type="BrightWire.ICreateTemplateBasedGradientDescent" name="AdaGrad">
		<summary>Adagrad gradient descent</summary>
	</property>
	<property type="BrightWire.ICreateTemplateBasedGradientDescent" name="Adam">
		<summary>Adam gradient descent</summary>
	</property>
	<property type="BrightWire.ICreateTemplateBasedGradientDescent" name="Momentum">
		<summary>Momentum gradient descent</summary>
	</property>
	<property type="BrightWire.ICreateTemplateBasedGradientDescent" name="NesterovMomentum">
		<summary>Nesterov momentum gradient descent</summary>
	</property>
	<property type="BrightWire.ICreateTemplateBasedGradientDescent" name="RmsProp">
		<summary>Rms prop gradient descent</summary>
	</property>
</class>
<class name="BrightWire.ExecutionGraph.GraphFactory" base="" is-static="false" is-abstract="false">
	<summary>
		Creates graph nodes
	</summary>
	<method type="System.Void" name="GraphFactory" is-static="false">
		<summary>Constructor</summary>
				<param type="BrightWire.ILinearAlgebraProvider" name="lap" summary="The linear algebra provider to use" />
				<param type="BrightWire.IPropertySet" name="propertySet" summary="A property set with initialisation data (optional)" />
			</method>
	<property type="BrightWire.ILinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary>Linear algebra provider</summary>
	</property>
	<property type="BrightWire.IPropertySet" name="CurrentPropertySet">
		<summary>The current property set</summary>
	</property>
	<method type="System.Void" name="PushPropertySet" is-static="false">
		<summary>Clones the current property set with an optional mutator and then pushes it onto the stack</summary>
				<param type="System.Action&lt;BrightWire.IPropertySet&gt;" name="mutator" summary="Callback that can modify the cloned property set" />
			</method>
	<method type="System.Void" name="PopPropertyStack" is-static="false">
		<summary>Pops the last property set from the stack</summary>
			</method>
	<method type="BrightWire.IGradientDescentOptimisation" name="CreateWeightUpdater" is-static="false">
		<summary>Creates a gradient descent optimiser for the given matrix</summary>
				<param type="BrightWire.IMatrix" name="weight" summary="" />
			</method>
	<method type="BrightWire.IExecutionContext" name="CreateExecutionContext" is-static="false">
		<summary>Creates a graph execution context</summary>
			</method>
	<method type="BrightWire.ILearningContext" name="CreateLearningContext" is-static="false">
		<summary>Creates a graph learning context</summary>
				<param type="System.Single" name="learningRate" summary="Initial learning rate" />
				<param type="System.Int32" name="batchSize" summary="Mini batch size" />
				<param type="BrightWire.TrainingErrorCalculation" name="trainingErrorCalculation" summary="How to calculate the training error" />
				<param type="System.Boolean" name="deferUpdates" summary="True to defer updates (used when training recurrent neural networks)" />
			</method>
	<method type="BrightWire.IGraphTrainingEngine" name="CreateTrainingEngine" is-static="false">
		<summary>Creates a graph training engine</summary>
				<param type="BrightWire.IDataSource" name="dataSource" summary="Data source with training data" />
				<param type="System.Single" name="learningRate" summary="Initial learning rate" />
				<param type="System.Int32" name="batchSize" summary="Mini batch size" />
				<param type="BrightWire.TrainingErrorCalculation" name="trainingErrorCalculation" summary="How to calculate the training error" />
			</method>
	<method type="BrightWire.IGraphTrainingEngine" name="CreateTrainingEngine" is-static="false">
		<summary>Creates a graph training engine</summary>
				<param type="BrightWire.IDataSource" name="dataSource" summary="Data source with training data" />
				<param type="BrightWire.Models.ExecutionGraph" name="graph" summary="The serialised graph to execute" />
				<param type="System.Single" name="trainingRate" summary="Initial learning rate" />
				<param type="System.Int32" name="batchSize" summary="Mini batch size" />
				<param type="BrightWire.TrainingErrorCalculation" name="trainingErrorCalculation" summary="How to calculate the training error" />
			</method>
	<method type="BrightWire.IGraphTrainingEngine" name="CreateTrainingEngine" is-static="false">
		<summary>Creates a graph training engine</summary>
				<param type="BrightWire.IDataSource" name="dataSource" summary="Data source with training data" />
				<param type="BrightWire.ILearningContext" name="learningContext" summary="Previously created training context" />
				<param type="BrightWire.Models.ExecutionGraph" name="graph" summary="The serialised graph to execute (optional)" />
			</method>
	<method type="BrightWire.IGraphEngine" name="CreateEngine" is-static="false">
		<summary>Creates a graph execution engine</summary>
				<param type="BrightWire.Models.ExecutionGraph" name="graph" summary="The serialised graph to execute" />
			</method>
	<method type="BrightWire.IDataSource" name="CreateDataSource" is-static="false">
		<summary>Creates a data source from a list of vectors</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;BrightWire.Models.FloatVector&gt;" name="vectorList" summary="The list of vectors that will be the rows in the data source" />
			</method>
	<method type="BrightWire.IDataSource" name="CreateDataSource" is-static="false">
		<summary>Creates a data source from a list of matrices (sequential vectors)</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;BrightWire.Models.FloatMatrix&gt;" name="sequenceList" summary="The list of matrices that will be the rows in the data source" />
			</method>
	<method type="BrightWire.IDataSource" name="CreateDataSource" is-static="false">
		<summary>Creates a data source from a list of matrices (sequential vectors)</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;BrightWire.Models.FloatTensor&gt;" name="tensorList" summary="The list of tensors that will be the rows in the data source" />
			</method>
	<method type="BrightWire.IDataSource" name="CreateDataSource" is-static="false">
		<summary>Creates a data source from a data table</summary>
				<param type="BrightWire.IDataTable" name="dataTable" summary="The data table to convert" />
				<param type="BrightWire.IDataTableVectoriser" name="vectoriser" summary="Optional data table vectoriser (if the data table contains categorical or index based data)" />
			</method>
	<method type="BrightWire.IDataSource" name="CreateDataSource" is-static="false">
		<summary>Creates an adaptive data source (that uses the output from a preliminary graph)</summary>
				<param type="BrightWire.IDataTable" name="dataTable" summary="Data that will be sent to the preliminary graph" />
				<param type="BrightWire.ILearningContext" name="learningContext" summary="Learning context to use while training the preliminary graph" />
				<param type="System.Action&lt;BrightWire.ExecutionGraph.WireBuilder&gt;" name="dataConversionBuilder" summary="Callback to build the preliminary graph" />
			</method>
	<method type="BrightWire.IDataSource" name="CreateDataSource" is-static="false">
		<summary>Creates an adaptive data source from a serialised model</summary>
				<param type="BrightWire.IDataTable" name="dataTable" summary="Data that will be sent to the preliminary graph" />
				<param type="BrightWire.Models.DataSourceModel" name="dataSource" summary="The serialised preliminary graph" />
				<param type="BrightWire.ILearningContext" name="learningContext" summary="Learning context to use while training the preliminary graph" />
			</method>
	<method type="(BrightWire.INode RowClassifier, System.Int32 OutputSize)" name="CreateClassifier" is-static="false">
		<summary>Create a row classifier node</summary>
				<param type="BrightWire.IRowClassifier" name="classifier" summary="The classifier for each row" />
				<param type="BrightWire.IDataTable" name="dataTable" summary="The data table that contains the rows to classify (linked by mini batch index)" />
				<param type="BrightWire.IDataTableAnalysis" name="analysis" summary="Optional data table analysis data" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.INode" name="CreateFeedForward" is-static="false">
		<summary>Creates a feed forward layer</summary>
				<param type="System.Int32" name="inputSize" summary="Number of incoming connections" />
				<param type="System.Int32" name="outputSize" summary="Number of outgoing connections" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.INode" name="CreateDropConnect" is-static="false">
		<summary>Creates a new drop connect layer (a feed forward layer with drop out applied to the weights)</summary>
				<param type="System.Single" name="dropoutPercentage" summary="Percentage of connections to drop (0..1)" />
				<param type="System.Int32" name="inputSize" summary="Number of incoming connections" />
				<param type="System.Int32" name="outputSize" summary="Number of outgoing connections" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.INode" name="CreateTiedFeedForward" is-static="false">
		<summary>Creates a layer whose weights are shared with another layer (but transposed)</summary>
				<param type="BrightWire.IFeedForward" name="layer" summary="The layer that shares weights" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.INode" name="CreateConvolutional" is-static="false">
		<summary>Creates a convolutional layer</summary>
				<param type="System.Int32" name="inputDepth" summary="Input depth" />
				<param type="System.Int32" name="filterCount" summary="Number of convolutional filters" />
				<param type="System.Int32" name="padding" summary="Padding to apply before convolutions" />
				<param type="System.Int32" name="filterWidth" summary="Width of each filter" />
				<param type="System.Int32" name="filterHeight" summary="Height of each filter" />
				<param type="System.Int32" name="stride" summary="Convolutional stride" />
				<param type="System.Boolean" name="shouldBackpropagate" summary="True to backpropagate an error signal" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.INode" name="CreateMaxPool" is-static="false">
		<summary>Creates a max pooling convolutional layer</summary>
				<param type="System.Int32" name="filterWidth" summary="" />
				<param type="System.Int32" name="filterHeight" summary="" />
				<param type="System.Int32" name="stride" summary="" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.INode" name="CreateSimpleRecurrent" is-static="false">
		<summary>Creates a simple recurrent layer</summary>
				<param type="System.Int32" name="inputSize" summary="Number of incoming connections" />
				<param type="System.Single[]" name="memory" summary="Size of the layer memory" />
				<param type="BrightWire.INode" name="activation" summary="Activation layer" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.INode" name="CreateElman" is-static="false">
		<summary>Creates an Elman recurrent layer</summary>
				<param type="System.Int32" name="inputSize" summary="Number of incoming connections" />
				<param type="System.Single[]" name="memory" summary="Size of the layer memory" />
				<param type="BrightWire.INode" name="activation" summary="First activation layer" />
				<param type="BrightWire.INode" name="activation2" summary="Second activation layer" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.INode" name="CreateJordan" is-static="false">
		<summary>Creates a Jordan recurrent layer</summary>
				<param type="System.Int32" name="inputSize" summary="Number of incoming connections" />
				<param type="System.Single[]" name="memory" summary="Size of the layer memory" />
				<param type="BrightWire.INode" name="activation" summary="First activation layer" />
				<param type="BrightWire.INode" name="activation2" summary="Second activation layer" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.INode" name="CreateOneMinusInput" is-static="false">
		<summary>Creates a node that subtracts each input from 1 (1-x)</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.INode" name="CreateSequenceReverser" is-static="false">
		<summary>Creates a node that outputs the reversed index of the current sequence (for bidirectional recurrent networks)</summary>
				<param type="System.Int32" name="index" summary="Input index to reverse" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.INode" name="CreateBatchNormalisation" is-static="false">
		<summary>Creates a batch normalisation layer (currently only implemented for FF layers)</summary>
				<param type="System.Int32" name="inputSize" summary="Number of incoming connections" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
				<param type="System.Single" name="momentum" summary="Online mean and variance rate of change" />
			</method>
	<method type="BrightWire.INode" name="CreateGru" is-static="false">
		<summary>Creates a GRU recurrent layer</summary>
				<param type="System.Int32" name="inputSize" summary="Number of incoming connections" />
				<param type="System.Single[]" name="memory" summary="Size of the layer memory" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.INode" name="CreateRan" is-static="false">
		<summary>Creates a Recurrent Additive Layer (recurrent)</summary>
				<param type="System.Int32" name="inputSize" summary="Number of incoming connections" />
				<param type="System.Single[]" name="memory" summary="Size of the layer memory" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.INode" name="CreateLstm" is-static="false">
		<summary>Creates a LSTM recurrent layer</summary>
				<param type="System.Int32" name="inputSize" summary="Number of incoming connections" />
				<param type="System.Single[]" name="memory" summary="Size of the layer memory" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.INode" name="CreateDropOut" is-static="false">
		<summary>Creates a layer that drops random connections</summary>
				<param type="System.Single" name="dropoutPercentage" summary="Percentage to drop (0..1)" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Connect" is-static="false">
		<summary>Builds a new wire from the engine's input node</summary>
				<param type="BrightWire.IGraphTrainingEngine" name="engine" summary="Graph engine to build with" />
				<param type="System.Int32" name="inputIndex" summary="Input index to connect to" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Connect" is-static="false">
		<summary>Builds a new wire from the selected node</summary>
				<param type="System.Int32" name="inputSize" summary="Number of outgoing connections" />
				<param type="BrightWire.INode" name="node" summary="The node to build from" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Connect" is-static="false">
		<summary>Builds a new wire from the selected node</summary>
				<param type="System.Int32" name="width" summary="Volume width" />
				<param type="System.Int32" name="height" summary="Volume height" />
				<param type="System.Int32" name="depth" summary="Volume depth" />
				<param type="BrightWire.INode" name="node" summary="The node to build from" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Add" is-static="false">
		<summary>Adds the output of two wires into a new wire</summary>
				<param type="BrightWire.ExecutionGraph.WireBuilder" name="input1" summary="First wire" />
				<param type="BrightWire.ExecutionGraph.WireBuilder" name="input2" summary="Second wire" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Subtract" is-static="false">
		<summary>Subtracts the second input from the first input and sends the result to a new wire</summary>
				<param type="BrightWire.ExecutionGraph.WireBuilder" name="input1" summary="Wire to subtract from" />
				<param type="BrightWire.ExecutionGraph.WireBuilder" name="input2" summary="Wire to subtract" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Subtract" is-static="false">
		<summary>Subtracts the second input from the first input and sends the result to a new wire</summary>
				<param type="System.Int32" name="inputSize" summary="The number of connections" />
				<param type="BrightWire.INode" name="input1" summary="The node to subtract from" />
				<param type="BrightWire.INode" name="input2" summary="The node to subtract" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Add" is-static="false">
		<summary>Adds the output of two nodes together into a new wire</summary>
				<param type="System.Int32" name="inputSize" summary="The number of connections" />
				<param type="BrightWire.INode" name="input1" summary="First node" />
				<param type="BrightWire.INode" name="input2" summary="Second node" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Multiply" is-static="false">
		<summary>Multiplies the output of two wires into a new wire</summary>
				<param type="BrightWire.ExecutionGraph.WireBuilder" name="input1" summary="" />
				<param type="BrightWire.ExecutionGraph.WireBuilder" name="input2" summary="" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Multiply" is-static="false">
		<summary>Multiplies the output of two nodes together into a new wire</summary>
				<param type="System.Int32" name="inputSize" summary="The number of connections" />
				<param type="BrightWire.INode" name="input1" summary="First node" />
				<param type="BrightWire.INode" name="input2" summary="Second node" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Join" is-static="false">
		<summary>Concatenates two wires together into a new wire</summary>
				<param type="BrightWire.ExecutionGraph.WireBuilder" name="input1" summary="First wire to join" />
				<param type="BrightWire.ExecutionGraph.WireBuilder" name="input2" summary="Second wire to join" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="ReverseTemporalJoin" is-static="false">
		<summary>Concatenates two wires together into a new wire, but reverses the temporal index of the second input to realign with reversed sequences</summary>
				<param type="BrightWire.ExecutionGraph.WireBuilder" name="forwardInput" summary="Forward wire to join" />
				<param type="BrightWire.ExecutionGraph.WireBuilder" name="backwardInput" summary="Backward wire to join" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.INode" name="CreateWrapper" is-static="false">
		<summary>Wraps an existing node, enabling that node to be used at multiple locations in the same graph</summary>
				<param type="BrightWire.INode" name="nodeToWrap" summary="Node to wrap" />
				<param type="System.String" name="name" summary="Optional name to give the wrapping node" />
			</method>
	<method type="BrightWire.INode" name="Create" is-static="false">
		<summary>Creates a node from it's serialised model</summary>
				<param type="BrightWire.Models.ExecutionGraph.Node" name="node" summary="The node model" />
			</method>
	<method type="BrightWire.INode" name="LeakyReluActivation" is-static="false">
		<summary>Creates a new leaky relu activation layer</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.INode" name="ReluActivation" is-static="false">
		<summary>Creates a new relu activation layer</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.INode" name="SigmoidActivation" is-static="false">
		<summary>Creates a new sigmoid activation layer</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.INode" name="TanhActivation" is-static="false">
		<summary>Creates a new tanh activation layer</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.INode" name="SoftMaxActivation" is-static="false">
		<summary>Creates a new softmax activation layer</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.IWeightInitialisation" name="ConstantWeightInitialisation" is-static="false">
		<summary>Creates a constant weight initialiser</summary>
				<param type="System.Single" name="biasValue" summary="Single bias value" />
				<param type="System.Single" name="weightValue" summary="Single weight value" />
			</method>
	<method type="BrightWire.IWeightInitialisation" name="GaussianWeightInitialisation" is-static="false">
		<summary>Creates a gaussian weight initialiser</summary>
				<param type="System.Boolean" name="zeroBias" summary="True to set bias values to zero, otherwise bias initialisation is treated the same as weight initialisation" />
				<param type="System.Single" name="stdDev" summary="Standard deviation of gaussian distribution" />
				<param type="BrightWire.GaussianVarianceCalibration" name="varianceCalibration" summary="How to calibrate the variance" />
				<param type="BrightWire.GaussianVarianceCount" name="varianceCount" summary="How to count connections while calibrating connections" />
			</method>
	<method type="BrightWire.IWeightInitialisation" name="IdentityWeightInitialisation" is-static="false">
		<summary>Creates an identity weight initialiser</summary>
				<param type="System.Single" name="identityValue" summary="The value to give to each diagonal value" />
			</method>
	<method type="BrightWire.IWeightInitialisation" name="XavierWeightInitialisation" is-static="false">
		<summary>Creates a xavier weight initialiser</summary>
				<param type="System.Single" name="parameter" summary="Xavier parameter" />
			</method>
	<method type="BrightWire.ICreateTemplateBasedGradientDescent" name="AdaGrad" is-static="false">
		<summary>Creates an AdaGrad gradient descent optimiser</summary>
			</method>
	<method type="BrightWire.ICreateTemplateBasedGradientDescent" name="Adam" is-static="false">
		<summary>Creates an Adam gradient descent optimiser</summary>
				<param type="System.Single" name="decay" summary="Decay parameter" />
				<param type="System.Single" name="decay2" summary="Second decay parameter" />
			</method>
	<method type="BrightWire.ICreateGradientDescent" name="L1" is-static="false">
		<summary>Creates a L1 regularisation gradient descent optimiser</summary>
				<param type="System.Single" name="lambda" summary="L1 parameter" />
			</method>
	<method type="BrightWire.ICreateGradientDescent" name="L2" is-static="false">
		<summary>Creates a L2 regularisation gradient descent optimiser</summary>
				<param type="System.Single" name="lambda" summary="L2 parameter" />
			</method>
	<method type="BrightWire.ICreateTemplateBasedGradientDescent" name="Momentum" is-static="false">
		<summary>Creats a momentum gradient descent optimiser</summary>
				<param type="System.Single" name="momentum" summary="Momentum parameter" />
			</method>
	<method type="BrightWire.ICreateTemplateBasedGradientDescent" name="NesterovMomentum" is-static="false">
		<summary>Creates a nesterov momentum gradient descent optimiser</summary>
				<param type="System.Single" name="momentum" summary="Nesterov momentum parameter" />
			</method>
	<method type="BrightWire.ICreateTemplateBasedGradientDescent" name="RmsProp" is-static="false">
		<summary>Creates a rms prop gradient descent optimiser</summary>
				<param type="System.Single" name="decay" summary="Rms decay" />
			</method>
	<property type="BrightWire.ExecutionGraph.GraphFactory.RegularisationProvider" name="Regularisation">
		<summary>Prebuilt regularisation</summary>
	</property>
	<property type="BrightWire.ExecutionGraph.GraphFactory.GradientDescentProvider" name="GradientDescent">
		<summary>Prebuilt gradient descent optimisers</summary>
	</property>
	<property type="BrightWire.ExecutionGraph.GraphFactory.ErrorMetricProvider" name="ErrorMetric">
		<summary>Error metrics</summary>
	</property>
	<property type="BrightWire.ExecutionGraph.GraphFactory.WeightInitialisationProvider" name="WeightInitialisation">
		<summary>Prebuilt weight initialisers</summary>
	</property>
</class>
<class name="BrightWire.Models.GraphModel" base="" is-static="false" is-abstract="false">
	<summary>
		A serialised graph
	</summary>
	<property type="System.String" name="Version">
		<summary>Data contract version number</summary>
	</property>
	<property type="System.String" name="Name">
		<summary>The name of the graph</summary>
	</property>
	<property type="BrightWire.Models.ExecutionGraph" name="Graph">
		<summary>The primary execution graph</summary>
	</property>
	<property type="BrightWire.Models.DataSourceModel" name="DataSource">
		<summary>Optional data source associated with the model</summary>
	</property>
</class>
<class name="BrightWire.TrainingData.WellKnown.Mnist.Image" base="" is-static="false" is-abstract="false">
	<summary>
		Image data
	</summary>
	<property type="System.Byte[]" name="Data">
		<summary>The image data</summary>
	</property>
	<property type="System.Int32" name="Label">
		<summary>The image number (0-9)</summary>
	</property>
	<property type="(BrightWire.Models.FloatVector Data, BrightWire.Models.FloatVector Label)" name="AsFloatArray">
		<summary>Converts the image to one hot encoded float arrays</summary>
	</property>
	<property type="(BrightWire.Models.FloatTensor Tensor, BrightWire.Models.FloatVector Label)" name="AsFloatTensor">
		<summary>Converts the image to a tensor with one hot encoded label vector</summary>
	</property>
</class>
<class name="BrightWire.Models.IndexList" base="" is-static="false" is-abstract="false">
	<summary>
		A protobuf serialisable sparse array of indices
	</summary>
	<property type="System.UInt32[]" name="Index">
		<summary>The list of indices</summary>
	</property>
	<method type="BrightWire.Models.IndexList" name="Create" is-static="true">
		<summary>Create a new index list with the specified indices</summary>
				<param type="System.UInt32[]" name="index" summary="Sparse list of indices" />
			</method>
	<property type="System.Int32" name="Count">
		<summary>The number of items in the list</summary>
	</property>
	<method type="System.String" name="ToString" is-static="false">
		<summary>ToString override</summary>
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary>Writes the data to an XML writer</summary>
				<param type="System.String" name="name" summary="The name to give the data" />
				<param type="System.Xml.XmlWriter" name="writer" summary="The writer to write to" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary>Writes the data to a binary writer</summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="BrightWire.Models.IndexList" name="ReadFrom" is-static="true">
		<summary>Creates an index list from a binary reader</summary>
				<param type="System.IO.BinaryReader" name="reader" summary="The binary reader" />
			</method>
	<property type="System.String" name="Xml">
		<summary>Converts the index list to XML</summary>
	</property>
</class>
<class name="BrightWire.Models.InstanceBased.KNearestNeighbours" base="" is-static="false" is-abstract="false">
	<summary>
		K Nearest Neighbour Model
	</summary>
	<property type="BrightWire.Models.FloatVector[]" name="Instance">
		<summary>The list of vectors to match against</summary>
	</property>
	<property type="System.String[]" name="Classification">
		<summary>The corresponding list of classifications</summary>
	</property>
	<property type="System.Int32[]" name="FeatureColumn">
		<summary>The vector indexes to use to encode a data table row as a vector</summary>
	</property>
	<method type="BrightWire.IRowClassifier" name="CreateClassifier" is-static="false">
		<summary>Creates a classifier from this model</summary>
				<param type="BrightWire.ILinearAlgebraProvider" name="lap" summary="The linear algebra provider" />
				<param type="System.Int32" name="k" summary="The number of instances to consider" />
				<param type="BrightWire.DistanceMetric" name="distanceMetric" summary="The distance metric to compare each row with each instance" />
			</method>
</class>
<class name="BrightWire.Models.LinearRegression" base="" is-static="false" is-abstract="false">
	<summary>
		A linear regression model
	</summary>
	<property type="BrightWire.Models.FloatVector" name="Theta">
		<summary>The model parameters</summary>
	</property>
	<method type="BrightWire.ILinearRegressionPredictor" name="CreatePredictor" is-static="false">
		<summary>Creates a predictor from this model</summary>
				<param type="BrightWire.ILinearAlgebraProvider" name="lap" summary="The linear algebra provider" />
			</method>
</class>
<class name="BrightWire.Models.LogisticRegression" base="" is-static="false" is-abstract="false">
	<summary>
		A logistic regression model
	</summary>
	<property type="BrightWire.Models.FloatVector" name="Theta">
		<summary>The model parameters</summary>
	</property>
	<method type="BrightWire.ILogisticRegressionClassifier" name="CreatePredictor" is-static="false">
		<summary>Creates a classifier from this model</summary>
				<param type="BrightWire.ILinearAlgebraProvider" name="lap" summary="Linear algebra provider" />
			</method>
</class>
<class name="BrightWire.Models.Bayesian.MarkovModel2&lt;T&gt;" base="" is-static="false" is-abstract="false">
	<summary>
		A markov model based on observing two items at a time
	</summary>
	<property type="BrightWire.Models.Bayesian.MarkovModelObservation2&lt;T&gt;[]" name="Observation">
		<summary>The list of observations</summary>
	</property>
	<property type="System.Collections.Generic.Dictionary&lt;BrightWire.Models.Bayesian.MarkovModelObservation2&lt;T&gt;, System.Collections.Generic.List&lt;BrightWire.Models.Bayesian.MarkovModelStateTransition&lt;T&gt;&gt;&gt;" name="AsDictionary">
		<summary>Converts the model to a dictionary</summary>
	</property>
</class>
<class name="BrightWire.Models.Bayesian.MarkovModel3&lt;T&gt;" base="" is-static="false" is-abstract="false">
	<summary>
		A markov model based on observing the last three observations
	</summary>
	<property type="BrightWire.Models.Bayesian.MarkovModelObservation3&lt;T&gt;[]" name="Observation">
		<summary>The list of observations</summary>
	</property>
	<property type="System.Collections.Generic.Dictionary&lt;BrightWire.Models.Bayesian.MarkovModelObservation3&lt;T&gt;, System.Collections.Generic.List&lt;BrightWire.Models.Bayesian.MarkovModelStateTransition&lt;T&gt;&gt;&gt;" name="AsDictionary">
		<summary>Converts the model to a dictionary</summary>
	</property>
</class>
<class name="BrightWire.Models.Bayesian.MarkovModelObservation2&lt;T&gt;" base="" is-static="false" is-abstract="false">
	<summary>
		A markov model observation based on the preceding two items
	</summary>
	<property type="T" name="Item1">
		<summary>The second last preceding item</summary>
	</property>
	<property type="T" name="Item2">
		<summary>The last preceding item</summary>
	</property>
	<property type="System.Collections.Generic.List&lt;BrightWire.Models.Bayesian.MarkovModelStateTransition&lt;T&gt;&gt;" name="Transition">
		<summary>The list of possible transitions from this state</summary>
	</property>
	<method type="System.Boolean" name="Equals" is-static="false">
		<summary>Equals overide</summary>
				<param type="System.Object" name="obj" summary="" />
			</method>
	<method type="System.Int32" name="GetHashCode" is-static="false">
		<summary>Hash code override</summary>
			</method>
</class>
<class name="BrightWire.Models.Bayesian.MarkovModelObservation3&lt;T&gt;" base="" is-static="false" is-abstract="false">
	<summary>
		A markov model observation based on the preceding three instances
	</summary>
	<property type="T" name="Item1">
		<summary>The third last item</summary>
	</property>
	<property type="T" name="Item2">
		<summary>The second last item</summary>
	</property>
	<property type="T" name="Item3">
		<summary>The third last item</summary>
	</property>
	<property type="System.Collections.Generic.List&lt;BrightWire.Models.Bayesian.MarkovModelStateTransition&lt;T&gt;&gt;" name="Transition">
		<summary>The list of associated transitions</summary>
	</property>
	<method type="System.Boolean" name="Equals" is-static="false">
		<summary>Equals override</summary>
				<param type="System.Object" name="obj" summary="" />
			</method>
	<method type="System.Int32" name="GetHashCode" is-static="false">
		<summary>Hashcode override</summary>
			</method>
</class>
<class name="BrightWire.Models.Bayesian.MarkovModelStateTransition&lt;T&gt;" base="" is-static="false" is-abstract="false">
	<summary>
		A markov model state transition
	</summary>
	<property type="T" name="NextState">
		<summary>The next state</summary>
	</property>
	<property type="System.Single" name="Probability">
		<summary>The probability of this next state</summary>
	</property>
</class>
<class name="BrightWire.TrainingData.WellKnown.Mnist" base="" is-static="true" is-abstract="false">
	<summary>
		Helper class for MNIST data: http://yann.lecun.com/exdb/mnist/
	</summary>
	<method type="System.Collections.Generic.IReadOnlyList&lt;BrightWire.TrainingData.WellKnown.Mnist.Image&gt;" name="Load" is-static="true">
		<summary>Loads a set of images from the MNIST data files</summary>
				<param type="System.String" name="labelPath" summary="Path to the label data file" />
				<param type="System.String" name="imagePath" summary="Path to the image data file" />
				<param type="System.Int32" name="total" summary="Maximum number of images to load" />
			</method>
</class>
<class name="BrightWire.ExecutionGraph.Node.Gate.MultiGateBase" base="BrightWire.ExecutionGraph.Node.NodeBase" is-static="false" is-abstract="true">
	<summary>
		Base class for nodes that accept input on an arbitary number of channels and output a single signal
	</summary>
	<method type="System.Void" name="MultiGateBase" is-static="false">
		<summary>Constructor</summary>
				<param type="System.String" name="name" summary="The name of the node (optional)" />
				<param type="BrightWire.ExecutionGraph.WireBuilder[]" name="incoming" summary="The list of incoming wires" />
			</method>
	<method type="System.Void" name="ExecuteForward" is-static="false">
		<summary>Executes on the primary channel</summary>
				<param type="BrightWire.IContext" name="context" summary="The graph context" />
			</method>
	<method type="System.Void" name="ReadFrom" is-static="false">
		<summary></summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="factory" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
</class>
<class name="BrightWire.Models.MultinomialLogisticRegression" base="" is-static="false" is-abstract="false">
	<summary>
		Multinomial logistic regression model
	</summary>
	<property type="BrightWire.Models.LogisticRegression[]" name="Model">
		<summary>The list of logistic regression models</summary>
	</property>
	<property type="System.String[]" name="Classification">
		<summary>The associated classification labels</summary>
	</property>
	<property type="System.Int32[]" name="FeatureColumn">
		<summary>The columns used to build the dense input vectors</summary>
	</property>
	<method type="BrightWire.IRowClassifier" name="CreateClassifier" is-static="false">
		<summary>Creates a classifier from this model</summary>
				<param type="BrightWire.ILinearAlgebraProvider" name="lap" summary="Linear algebra provider" />
			</method>
</class>
<class name="BrightWire.Models.Bayesian.MultinomialNaiveBayes" base="" is-static="false" is-abstract="false">
	<summary>
		Multinomial naive bayes model
	</summary>
	<property type="BrightWire.Models.Bayesian.MultinomialNaiveBayes.Class[]" name="ClassData">
		<summary>The list of possible classifications</summary>
	</property>
	<method type="BrightWire.IIndexListClassifier" name="CreateClassifier" is-static="false">
		<summary>Creates a classifier from the model</summary>
			</method>
</class>
<class name="BrightWire.Models.Bayesian.NaiveBayes" base="" is-static="false" is-abstract="false">
	<summary>
		A naive bayes model
	</summary>
	<property type="System.Collections.Generic.List&lt;BrightWire.Models.Bayesian.NaiveBayes.ClassSummary&gt;" name="Class">
		<summary>A list of possible classifications and their data</summary>
	</property>
	<method type="BrightWire.IRowClassifier" name="CreateClassifier" is-static="false">
		<summary>Creates a classifier from this model</summary>
			</method>
</class>
<class name="BrightWire.Models.ExecutionGraph.Node" base="" is-static="false" is-abstract="false">
	<summary>
		A node within the graph
	</summary>
	<property type="System.String" name="TypeName">
		<summary>The .NET type name of the node type</summary>
	</property>
	<property type="System.String" name="Id">
		<summary>The unique id within the graph</summary>
	</property>
	<property type="System.String" name="Name">
		<summary>Node friendly name</summary>
	</property>
	<property type="System.String" name="Description">
		<summary>A short description of the node</summary>
	</property>
	<property type="System.Byte[]" name="Data">
		<summary>The node's parameters</summary>
	</property>
</class>
<class name="BrightWire.Models.DecisionTree.Node" base="" is-static="false" is-abstract="false">
	<summary>
		A node in the decision tree
	</summary>
	<property type="BrightWire.Models.DecisionTree.Node[]" name="Children">
		<summary>The nodes children</summary>
	</property>
	<property type="System.Int32" name="ColumnIndex">
		<summary>The column index that is being split on</summary>
	</property>
	<property type="System.String" name="MatchLabel">
		<summary>The value to match this node</summary>
	</property>
	<property type="System.Nullable&lt;System.Double&gt;" name="Split">
		<summary>The value to split on</summary>
	</property>
	<property type="System.String" name="Classification">
		<summary>This node's classification label</summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary>Writes the node as XML</summary>
				<param type="System.Xml.XmlWriter" name="writer" summary="The XML writer" />
			</method>
</class>
<class name="BrightWire.ExecutionGraph.Node.NodeBase" base="" is-static="false" is-abstract="true">
	<summary>
		Base class for graph nodes
	</summary>
	<method type="System.Void" name="NodeBase" is-static="false">
		<summary>Constructor</summary>
				<param type="System.String" name="name" summary="The name of the node (optional)" />
				<param type="System.String" name="id" summary="The node's unique id (optional)" />
			</method>
	<method type="System.Void" name="Dispose" is-static="false">
		<summary>Disposal</summary>
			</method>
	<property type="System.String" name="Id">
		<summary>The node's unique id</summary>
	</property>
	<property type="System.String" name="Name">
		<summary>The node's name in the graph</summary>
	</property>
	<property type="System.Collections.Generic.List&lt;BrightWire.IWire&gt;" name="Output">
		<summary>The list of outgoing wires along which the output signal will be sent</summary>
	</property>
	<method type="System.Void" name="ExecuteForward" is-static="false">
		<summary>Called when executing forward on the primary channel</summary>
				<param type="BrightWire.IContext" name="context" summary="" />
			</method>
	<method type="System.Void" name="ExecuteForward" is-static="false">
		<summary>Called when executing forward</summary>
				<param type="BrightWire.IContext" name="context" summary="" />
				<param type="System.Int32" name="channel" summary="" />
			</method>
	<method type="BrightWire.Models.ExecutionGraph.Node" name="SerialiseTo" is-static="false">
		<summary>Serialise this node and any connected nodes</summary>
				<param type="System.Collections.Generic.HashSet&lt;BrightWire.INode&gt;" name="existing" summary="Set of nodes that have already been serialised in the current context" />
				<param type="System.Collections.Generic.List&lt;BrightWire.Models.ExecutionGraph.Node&gt;" name="connectedTo" summary="List of nodes this node is connected to" />
				<param type="System.Collections.Generic.HashSet&lt;BrightWire.Models.ExecutionGraph.Wire&gt;" name="wireList" summary="List of wires between all connected nodes" />
			</method>
	<method type="System.Void" name="OnDeserialise" is-static="false">
		<summary>Called after the graph has been completely deserialised</summary>
				<param type="System.Collections.Generic.IReadOnlyDictionary&lt;System.String, BrightWire.INode&gt;" name="graph" summary="The complete graph" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary>Serialise the node</summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="Binary writer" />
			</method>
	<method type="System.Void" name="ReadFrom" is-static="false">
		<summary>Deserialise the node</summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="factory" summary="Graph factory" />
				<param type="System.IO.BinaryReader" name="reader" summary="Binary reader" />
			</method>
	<method type="BrightWire.INode" name="FindByName" is-static="false">
		<summary>Finds a connected node by friendly name</summary>
				<param type="System.String" name="name" summary="The node's name to search for" />
			</method>
	<method type="BrightWire.INode" name="FindById" is-static="false">
		<summary>Finds a connected node by id</summary>
				<param type="System.String" name="id" summary="Unique id to find" />
			</method>
	<property type="System.Collections.Generic.IEnumerable&lt;BrightWire.INode&gt;" name="SubNodes">
		<summary>The list of sub-nodes</summary>
	</property>
	<method type="System.Void" name="LoadParameters" is-static="false">
		<summary>Loads parameters into an existing node</summary>
				<param type="BrightWire.Models.ExecutionGraph.Node" name="nodeData" summary="Serialised node parameters" />
			</method>
</class>
<class name="BrightWire.TrainingData.Artificial.Or" base="" is-static="true" is-abstract="false">
	<summary>
		Simple OR training data
	</summary>
	<method type="BrightWire.IDataTable" name="Get" is-static="true">
		<summary>Generates a data table containing OR training data</summary>
			</method>
</class>
<class name="BrightWire.Models.RandomForest" base="" is-static="false" is-abstract="false">
	<summary>
		A random forest model
	</summary>
	<property type="BrightWire.Models.DecisionTree[]" name="Forest">
		<summary>The list of trees in the forest</summary>
	</property>
	<method type="BrightWire.IRowClassifier" name="CreateClassifier" is-static="false">
		<summary>Creates a classifier from the model</summary>
			</method>
</class>
<class name="BrightWire.TrainingData.Artificial.ReberGrammar" base="" is-static="false" is-abstract="false">
	<summary>
		Generates Reber grammar sequences: https://www.willamette.edu/~gorr/classes/cs449/reber.html
	</summary>
	<method type="System.Char" name="GetChar" is-static="true">
		<summary>Gets the character at the specified index</summary>
				<param type="System.Int32" name="index" summary="Index to query" />
			</method>
	<method type="System.Int32" name="GetIndex" is-static="true">
		<summary>Gets the index for the specified character</summary>
				<param type="System.Char" name="ch" summary="The character to query" />
			</method>
	<method type="BrightWire.Models.FloatMatrix" name="Encode" is-static="true">
		<summary>Encodes a reber sequence as a sequence of one hot encoded vectors</summary>
				<param type="System.String" name="sequence" summary="The reber sequence to encode" />
			</method>
	<method type="BrightWire.IDataTable" name="GetOneHot" is-static="true">
		<summary>One hot encodes the REBER strings</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="strList" summary="A list of REBER sequences" />
			</method>
	<property type="System.Int32" name="Size">
		<summary>The number of REBER characters</summary>
	</property>
	<method type="System.Void" name="ReberGrammar" is-static="false">
		<summary>Creates a reber grammar builder</summary>
				<param type="System.Boolean" name="stochastic" summary="True to generate random sequences" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="Get" is-static="false">
		<summary>Generates an unlimited number of reber sequences</summary>
				<param type="System.Nullable&lt;System.Int32&gt;" name="length" summary="Optional required length of the sequences" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="GetExtended" is-static="false">
		<summary>Generates an unlimited number of extended reber sequences</summary>
				<param type="System.Nullable&lt;System.Int32&gt;" name="length" summary="Optional required length of the sequences" />
			</method>
</class>
<class name="BrightWire.ExecutionGraph.GraphFactory.RegularisationProvider" base="" is-static="false" is-abstract="false">
	<summary>
		Prebuilt regularisation
	</summary>
	<property type="BrightWire.ICreateGradientDescent" name="L1">
		<summary>L1 regularisation</summary>
	</property>
	<property type="BrightWire.ICreateGradientDescent" name="L2">
		<summary>L2 regularisation</summary>
	</property>
</class>
<class name="BrightWire.ExecutionGraph.Helper.MiniBatch.Sequence" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<property type="BrightWire.IMiniBatch" name="MiniBatch">
		<summary></summary>
	</property>
	<property type="System.Int32" name="SequenceIndex">
		<summary></summary>
	</property>
	<property type="BrightWire.MiniBatchSequenceType" name="Type">
		<summary></summary>
	</property>
	<property type="System.Collections.Generic.IReadOnlyList&lt;BrightWire.IGraphData&gt;" name="Input">
		<summary></summary>
	</property>
	<property type="BrightWire.IGraphData" name="Target">
		<summary></summary>
	</property>
</class>
<class name="BrightWire.TrainingData.Artificial.SequenceClassification" base="" is-static="false" is-abstract="false">
	<summary>
		Generates random alphabetical sequences
	</summary>
	<method type="System.Void" name="SequenceClassification" is-static="false">
		<summary>Constructor</summary>
				<param type="System.Int32" name="dictionarySize" summary="The number of letters to use" />
				<param type="System.Int32" name="minSize" summary="The minimum size of each sequence" />
				<param type="System.Int32" name="maxSize" summary="The maximum size of each sequence" />
				<param type="System.Boolean" name="noRepeat" summary="True to avoid repeating any previous character within each sequence" />
				<param type="System.Boolean" name="isStochastic" summary="True to generate different sequences each time" />
			</method>
	<property type="System.Int32" name="DictionarySize">
		<summary>The number of letters to use</summary>
	</property>
	<method type="System.String" name="NextSequence" is-static="false">
		<summary>Generates a new sequence</summary>
			</method>
	<method type="BrightWire.Models.FloatVector" name="Encode" is-static="false">
		<summary>Converts the character to a one hot encoded vector</summary>
				<param type="System.Char" name="ch" summary="" />
				<param type="System.Single" name="val" summary="" />
			</method>
	<method type="BrightWire.Models.FloatVector" name="Encode" is-static="false">
		<summary>Encodes the characters as a dense vector</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;(System.Char, System.Single)&gt;" name="data" summary="" />
			</method>
	<method type="BrightWire.Models.FloatMatrix" name="Encode" is-static="false">
		<summary>Encodes the string as a list of dense vectors within a matrix (each character becomes a row in the matrix)</summary>
				<param type="System.String" name="str" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="GenerateSequences" is-static="false">
		<summary>Generator function to generate new sequences</summary>
			</method>
</class>
<class name="BrightWire.TrainingData.Helper.SequenceWindowBuilder" base="" is-static="false" is-abstract="false">
	<summary>
		Creates a new training feature vector using a window of surrounding features at each point in the input sequence
	</summary>
	<method type="System.Void" name="SequenceWindowBuilder" is-static="false">
		<summary>Creates a new sequence window builder</summary>
				<param type="System.Int32" name="before" summary="The number of previous items to include before each item" />
				<param type="System.Int32" name="after" summary="The number of following items to include after each item" />
			</method>
	<method type="System.Collections.Generic.IReadOnlyList&lt;System.Single[]&gt;" name="Get" is-static="false">
		<summary>Augments a single sequence</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;System.Single[]&gt;" name="data" summary="The sequence to analyse" />
			</method>
	<property type="System.Int32" name="OutputSize">
		<summary>The size of the generated training data</summary>
	</property>
</class>
<class name="BrightWire.TrainingData.Helper.SimpleTokeniser" base="" is-static="true" is-abstract="false">
	<summary>
		Finds strings of words and numbers in a larger string
	</summary>
	<method type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="Tokenise" is-static="true">
		<summary>Splits the text into smaller word and number strings. Punctuation characters become single character strings.</summary>
				<param type="System.String" name="text" summary="The text to tokenise" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="JoinNegations" is-static="true">
		<summary>Simple token modification following "not".
Double not or punctuation stops the not mode</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="tokenList" summary="The list of tokens" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.IReadOnlyList&lt;System.String&gt;&gt;" name="FindSentences" is-static="true">
		<summary>Finds sentences from a list of strings</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="stringList" summary="The list of strings" />
			</method>
	<method type="System.Boolean" name="IsEndOfSentence" is-static="true">
		<summary>Checks if the string is an end of sentence token</summary>
				<param type="System.String" name="str" summary="The string to check" />
			</method>
</class>
<class name="BrightWire.TrainingData.SimpleTokeniser" base="" is-static="true" is-abstract="false">
	<summary>
		Finds strings of words and numbers in a larger string
	</summary>
	<method type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="Tokenise" is-static="true">
		<summary>Splits the text into smaller word and number strings. Punctuation characters become single character strings.</summary>
				<param type="System.String" name="text" summary="The text to tokenise" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="JoinNegations" is-static="true">
		<summary>Simple token modification following "not".
Double not or punctuation stops the not mode</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="tokenList" summary="The list of tokens" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.IReadOnlyList&lt;System.String&gt;&gt;" name="FindSentences" is-static="true">
		<summary>Finds sentences from a list of strings</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="stringList" summary="The list of strings" />
			</method>
	<method type="System.Boolean" name="IsEndOfSentence" is-static="true">
		<summary>Checks if the string is an end of sentence token</summary>
				<param type="System.String" name="str" summary="The string to check" />
			</method>
</class>
<class name="BrightWire.ExecutionGraph.SingleBackpropagationBase&lt;T&gt;" base="BrightWire.ExecutionGraph.Node.BackpropagationBase&lt;T&gt;" is-static="false" is-abstract="true">
	<summary>
		Base class for nodes that back propagate to a single parent
	</summary>
	<method type="System.Void" name="_Backward" is-static="false">
		<summary>Called when a valid error signal has been received</summary>
				<param type="BrightWire.INode" name="fromNode" summary="The node that sent the backpropagation signal" />
				<param type="BrightWire.IGraphData" name="errorSignal" summary="The backpropagating error" />
				<param type="BrightWire.IContext" name="context" summary="Graph context" />
				<param type="System.Collections.Generic.IReadOnlyList&lt;BrightWire.INode&gt;" name="parents" summary="Parents of the current node" />
			</method>
</class>
<class name="BrightWire.Models.Bayesian.BernoulliNaiveBayes.StringIndexProbability" base="" is-static="false" is-abstract="false">
	<summary>
		The probabilities associated with a string index
	</summary>
	<property type="System.UInt32" name="StringIndex">
		<summary>The string index</summary>
	</property>
	<property type="System.Double" name="ConditionalProbability">
		<summary>The log of the conditional probability</summary>
	</property>
	<property type="System.Double" name="InverseProbability">
		<summary>The log of the inverse conditional probability</summary>
	</property>
</class>
<class name="BrightWire.Models.Bayesian.MultinomialNaiveBayes.StringIndexProbability" base="" is-static="false" is-abstract="false">
	<summary>
		The conditional probability associated with a string index
	</summary>
	<property type="System.UInt32" name="StringIndex">
		<summary>The string index</summary>
	</property>
	<property type="System.Double" name="ConditionalProbability">
		<summary>The conditional probability</summary>
	</property>
</class>
<class name="BrightWire.Models.StringTable" base="" is-static="false" is-abstract="false">
	<summary>
		An array of indexed strings
	</summary>
	<property type="System.String[]" name="Data">
		<summary>The array of indexed strings</summary>
	</property>
</class>
<class name="BrightWire.TrainingData.Helper.StringTableBuilder" base="" is-static="false" is-abstract="false">
	<summary>
		Assigns string indices to strings
	</summary>
	<method type="System.Void" name="StringTableBuilder" is-static="false">
		<summary>Creates an empty string table builder</summary>
			</method>
	<method type="System.Void" name="StringTableBuilder" is-static="false">
		<summary>Creates a string table builder pre populated with an existing string table</summary>
				<param type="BrightWire.Models.StringTable" name="stringTable" summary="The string table to pre populate" />
			</method>
	<method type="System.Void" name="StringTableBuilder" is-static="false">
		<summary>Creates a string table builder pre populated with an existing string table</summary>
				<param type="System.String[]" name="stringTable" summary="The string table to pre populate" />
			</method>
	<method type="System.Boolean" name="TryGetIndex" is-static="false">
		<summary>Returns true if the string has already been added</summary>
				<param type="System.String" name="str" summary="The string to check" />
				<param type="System.UInt32" name="ret" summary="The string index" />
			</method>
	<method type="System.UInt32" name="GetIndex" is-static="false">
		<summary>Gets a string index for a string (creates a new index if not found)</summary>
				<param type="System.String" name="str" summary="The string to look up" />
			</method>
	<property type="BrightWire.Models.StringTable" name="StringTable">
		<summary>Serialises the string table</summary>
	</property>
	<property type="System.UInt32" name="Size">
		<summary>Returns the size of the string table</summary>
	</property>
	<method type="System.String" name="GetString" is-static="false">
		<summary>Returns the string at the specified index</summary>
				<param type="System.UInt32" name="index" summary="The string index" />
			</method>
</class>
<class name="BrightWire.TrainingData.StringTableBuilder" base="" is-static="false" is-abstract="false">
	<summary>
		Assigns string indices to strings
	</summary>
	<method type="System.Void" name="StringTableBuilder" is-static="false">
		<summary>Creates an empty string table builder</summary>
			</method>
	<method type="System.Void" name="StringTableBuilder" is-static="false">
		<summary>Creates a string table builder pre populated with an existing string table</summary>
				<param type="BrightWire.Models.StringTable" name="stringTable" summary="The string table to pre populate" />
			</method>
	<method type="System.Void" name="StringTableBuilder" is-static="false">
		<summary>Creates a string table builder pre populated with an existing string table</summary>
				<param type="System.String[]" name="stringTable" summary="The string table to pre populate" />
			</method>
	<method type="System.Boolean" name="TryGetIndex" is-static="false">
		<summary>Returns true if the string has already been added</summary>
				<param type="System.String" name="str" summary="The string to check" />
				<param type="System.UInt32" name="ret" summary="The string index" />
			</method>
	<method type="System.UInt32" name="GetIndex" is-static="false">
		<summary>Gets a string index for a string (creates a new index if not found)</summary>
				<param type="System.String" name="str" summary="The string to look up" />
			</method>
	<property type="BrightWire.Models.StringTable" name="StringTable">
		<summary>Serialises the string table</summary>
	</property>
	<property type="System.UInt32" name="Size">
		<summary>Returns the size of the string table</summary>
	</property>
	<method type="System.String" name="GetString" is-static="false">
		<summary>Returns the string at the specified index</summary>
				<param type="System.UInt32" name="index" summary="The string index" />
			</method>
</class>
<class name="BrightWire.Models.WeightedIndexList.WeightedIndex" base="" is-static="false" is-abstract="false">
	<summary>
		A weighted index
	</summary>
	<property type="System.UInt32" name="Index">
		<summary>Index</summary>
	</property>
	<property type="System.Single" name="Weight">
		<summary>Index weight</summary>
	</property>
</class>
<class name="BrightWire.Models.WeightedIndexList" base="" is-static="false" is-abstract="false">
	<summary>
		A protobuf serialisable sparse array of weighted indices
	</summary>
	<property type="BrightWire.Models.WeightedIndexList.WeightedIndex[]" name="IndexList">
		<summary>The list of indices</summary>
	</property>
	<method type="BrightWire.Models.WeightedIndexList" name="Create" is-static="true">
		<summary>Create a new weighted index list with the specified weighted indices</summary>
				<param type="BrightWire.Models.WeightedIndexList.WeightedIndex[]" name="indexList" summary="Sparse list of weighted indices" />
			</method>
	<property type="System.Int32" name="Count">
		<summary>The number of items in the list</summary>
	</property>
	<method type="System.String" name="ToString" is-static="false">
		<summary>ToString override</summary>
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary>Writes the data to an XML writer</summary>
				<param type="System.String" name="name" summary="The name to give the data" />
				<param type="System.Xml.XmlWriter" name="writer" summary="The writer to write to" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary>Writes the data to a binary writer</summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="BrightWire.Models.WeightedIndexList" name="ReadFrom" is-static="true">
		<summary>Creates a weighted index list from a binary reader</summary>
				<param type="System.IO.BinaryReader" name="reader" summary="The binary reader" />
			</method>
	<property type="System.String" name="Xml">
		<summary>Converts the weighted index list to XML</summary>
	</property>
</class>
<class name="BrightWire.ExecutionGraph.GraphFactory.WeightInitialisationProvider" base="" is-static="false" is-abstract="false">
	<summary>
		Prebuilt weight initialisers
	</summary>
	<property type="BrightWire.IWeightInitialisation" name="Ones">
		<summary>All weights are initialised to 1</summary>
	</property>
	<property type="BrightWire.IWeightInitialisation" name="Zeroes">
		<summary>All weights are initialised to 0</summary>
	</property>
	<property type="BrightWire.IWeightInitialisation" name="Gaussian">
		<summary>Weights are randomly initialised using a gaussian distribution</summary>
	</property>
	<property type="BrightWire.IWeightInitialisation" name="Xavier">
		<summary>Weights are randomly initialised using the xavier algorithm</summary>
	</property>
	<property type="BrightWire.IWeightInitialisation" name="Identity">
		<summary>Weights are initialised to the identity matrix</summary>
	</property>
	<property type="BrightWire.IWeightInitialisation" name="Identity01">
		<summary>Weights are initialised to the identity matrix / 10</summary>
	</property>
</class>
<class name="BrightWire.Models.ExecutionGraph.Wire" base="" is-static="false" is-abstract="false">
	<summary>
		Wires connect nodes (aka edges)
	</summary>
	<property type="System.String" name="FromId">
		<summary>The source node id</summary>
	</property>
	<property type="System.String" name="ToId">
		<summary>The target node id</summary>
	</property>
	<property type="System.Int32" name="InputChannel">
		<summary>The channel on the target node to send the source node's output</summary>
	</property>
	<method type="System.String" name="ToString" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Int32" name="GetHashCode" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Boolean" name="Equals" is-static="false">
		<summary></summary>
				<param type="System.Object" name="obj" summary="" />
			</method>
</class>
<class name="BrightWire.ExecutionGraph.WireBuilder" base="" is-static="false" is-abstract="false">
	<summary>
		Wires nodes together to build strands of a graph
	</summary>
	<method type="System.Void" name="WireBuilder" is-static="false">
		<summary>Connects new nodes starting from the specified node</summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="factory" summary="Graph factory" />
				<param type="System.Int32" name="size" summary="Initial wire size" />
				<param type="BrightWire.INode" name="node" summary="The node to build from" />
			</method>
	<method type="System.Void" name="WireBuilder" is-static="false">
		<summary>Connects new nodes starting from the specified node</summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="factory" summary="Graph factory" />
				<param type="System.Int32" name="width" summary="Initial input width" />
				<param type="System.Int32" name="height" summary="Initial input height" />
				<param type="System.Int32" name="depth" summary="Initial input depth" />
				<param type="BrightWire.INode" name="node" summary="The node to build from" />
			</method>
	<method type="System.Void" name="WireBuilder" is-static="false">
		<summary>Connects new nodes to the engine output node</summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="factory" summary="Graph factory" />
				<param type="BrightWire.IGraphTrainingEngine" name="engine" summary="Graph engine" />
				<param type="System.Int32" name="inputIndex" summary="Input index to connect" />
			</method>
	<property type="System.Int32" name="CurrentSize">
		<summary>The current wire size</summary>
	</property>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="SetNewSize" is-static="false">
		<summary>Changes the current size of the builder</summary>
				<param type="System.Int32" name="newSize" summary="New wire builder size" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="IncrementSizeBy" is-static="false">
		<summary>Changes the current wire's input size</summary>
				<param type="System.Int32" name="delta" summary="Amount to add to the current wire size" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddClassifier" is-static="false">
		<summary>Connects a row classifier</summary>
				<param type="BrightWire.IRowClassifier" name="classifier" summary="" />
				<param type="BrightWire.IDataTable" name="dataTable" summary="" />
				<param type="BrightWire.IDataTableAnalysis" name="analysis" summary="" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddFeedForward" is-static="false">
		<summary>Adds a feed forward layer</summary>
				<param type="System.Int32" name="outputSize" summary="Number of outgoing connections" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddTiedFeedForward" is-static="false">
		<summary>Adds a feed forward layer whose weights are tied to a previous layer</summary>
				<param type="BrightWire.IFeedForward" name="layer" summary="The layer whose weights are tied" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddDropOut" is-static="false">
		<summary>Adds a drop out layer</summary>
				<param type="System.Single" name="dropOutPercentage" summary="Percentage of connections to drop" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddDropConnect" is-static="false">
		<summary></summary>
				<param type="System.Single" name="dropOutPercentage" summary="Percentage of connections to drop" />
				<param type="System.Int32" name="outputSize" summary="Number of outgoing connections" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Add" is-static="false">
		<summary>Adds a node</summary>
				<param type="BrightWire.INode" name="node" summary="" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddForwardAction" is-static="false">
		<summary>Adds an action that will be executed in the forward pass</summary>
				<param type="BrightWire.IAction" name="action" summary="Action to execute" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddBackwardAction" is-static="false">
		<summary>Adds an action that will be executed in the backward pass</summary>
				<param type="BrightWire.IAction" name="action" summary="Action to execute" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddBatchNormalisation" is-static="false">
		<summary>Adds a batch normalisation layer (currently only implemented for FF layers)</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddSimpleRecurrent" is-static="false">
		<summary>Adds a simple recurrent neural network layer</summary>
				<param type="BrightWire.INode" name="activation" summary="Activation layer" />
				<param type="System.Single[]" name="initialMemory" summary="Initial memory" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddElman" is-static="false">
		<summary>Adds an Elman recurrent neural network layer</summary>
				<param type="BrightWire.INode" name="activation" summary="First activation layer" />
				<param type="BrightWire.INode" name="activation2" summary="Second activation layer" />
				<param type="System.Single[]" name="initialMemory" summary="Initial memory" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddJordan" is-static="false">
		<summary>Adds a Jordan recurrent neural network layer</summary>
				<param type="BrightWire.INode" name="activation" summary="First activation layer" />
				<param type="BrightWire.INode" name="activation2" summary="Second activation layer" />
				<param type="System.Single[]" name="initialMemory" summary="Initial memory" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddGru" is-static="false">
		<summary>Adds a gated recurrent unit recurrent neural network layer</summary>
				<param type="System.Single[]" name="initialMemory" summary="Initial memory" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddRan" is-static="false">
		<summary>Adds a recurrent additive layer (recurrent)</summary>
				<param type="System.Single[]" name="initialMemory" summary="Initial memory" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddLstm" is-static="false">
		<summary>Adds a long short term memory recurrent neural network layer</summary>
				<param type="System.Single[]" name="initialMemory" summary="Initial memory" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="ReverseSequence" is-static="false">
		<summary>Adds a node that will reverse the sequence (for bidirectional recurrent neural networks)</summary>
				<param type="System.Int32" name="index" summary="Input index to reverse" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddMaxPooling" is-static="false">
		<summary>Adds a max pooling convolutional layer</summary>
				<param type="System.Int32" name="filterWidth" summary="Width of max pooliing filter" />
				<param type="System.Int32" name="filterHeight" summary="Height of max pooling filter" />
				<param type="System.Int32" name="stride" summary="Filter stride" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddConvolutional" is-static="false">
		<summary>Adds a convolutional layer</summary>
				<param type="System.Int32" name="filterCount" summary="Number of filters in the layer" />
				<param type="System.Int32" name="padding" summary="Padding to add before applying the convolutions" />
				<param type="System.Int32" name="filterWidth" summary="Width of each filter" />
				<param type="System.Int32" name="filterHeight" summary="Height of each filter" />
				<param type="System.Int32" name="stride" summary="Filter stride" />
				<param type="System.Boolean" name="shouldBackpropagate" summary="True to calculate a backpropagation signal" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Transpose" is-static="false">
		<summary>Transposes the graph signal to move between convolutional and non-convolutional layers</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="TransposeAndCombine" is-static="false">
		<summary>Transposes the graph signal and merges each depth slice</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddBackpropagation" is-static="false">
		<summary>Adds backpropagation - when executed an error signal will be calculated and flow backwards to previous nodes</summary>
				<param type="BrightWire.IErrorMetric" name="errorMetric" summary="Error metric to calculate the error signal" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddBackpropagationThroughTime" is-static="false">
		<summary>Adds backpropagation through time</summary>
				<param type="BrightWire.IErrorMetric" name="errorMetric" summary="Error metric to calculate the error signal" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="ConstrainForwardSignal" is-static="false">
		<summary>Constrains the error signal in the forward direction</summary>
				<param type="System.Single" name="min" summary="Minimum allowed value" />
				<param type="System.Single" name="max" summary="Maximum allowed value" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="ConstrainBackwardSignal" is-static="false">
		<summary>Constrains the error signal in the backward direction</summary>
				<param type="System.Single" name="min" summary="Minimum allowed value" />
				<param type="System.Single" name="max" summary="Maximum allowed value" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="WriteNodeMemoryToSlot" is-static="false">
		<summary>Writes node memory to a named memory slot</summary>
				<param type="System.String" name="slotName" summary="Memory slot name" />
				<param type="BrightWire.IHaveMemoryNode" name="node" summary="The node to read" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="JoinInputWithMemory" is-static="false">
		<summary>Concatenates the named memory slot with the input signal</summary>
				<param type="System.String" name="slotName" summary="Memory slot name" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.INode" name="Find" is-static="false">
		<summary>Tries to find the specified node</summary>
				<param type="System.String" name="name" summary="The friendly name of the node" />
			</method>
	<property type="BrightWire.INode" name="LastNode">
		<summary>The last added node</summary>
	</property>
</class>
<class name="BrightWire.TrainingData.Artificial.Xor" base="" is-static="true" is-abstract="false">
	<summary>
		Simple XOR training data
	</summary>
	<method type="BrightWire.IDataTable" name="Get" is-static="true">
		<summary>Generates a data table containing XOR training data</summary>
			</method>
</class>
</assembly>
